-->

↑ Jump to Table of Contents→ Pop Out Sidebar

W3C
WebAssembly Core Specification
Editor’s Draft, 9 April 2020

This version:
    https://webassembly.github.io/spec/core/bikeshed/ 
Latest published version:
    https://www.w3.org/TR/wasm-core-1/ 
Editor:
    Andreas Rossberg (Dfinity Stiftung) 
Issue Tracking:
    GitHub Issues 

Copyright © 2020 W3C® (MIT, ERCIM, Keio, Beihang). W3C liability, trademark and permissive document license rules apply.
Abstract

This document describes version 1.0 of the core WebAssembly standard, a safe, portable, low-level code format designed for efficient execution and compact representation.
Part of a collection of related documents: the Core WebAssembly Specification, the WebAssembly JS Interface, and the WebAssembly Web API.
Status of this document

This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

GitHub Issues are preferred for discussion of this specification. All issues and comments are archived.

This document was produced by the WebAssembly Working Group.

This document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 March 2019 W3C Process Document.

Table of Contents

    1 Introduction
        1.1 Introduction
            1.1.1 Design Goals
            1.1.2 Scope
            1.1.3 Security Considerations
            1.1.4 Dependencies 
        1.2 Overview
            1.2.1 Concepts
            1.2.2 Semantic Phases 
    2 Structure
        2.1 Conventions
            2.1.1 Grammar Notation
            2.1.2 Auxiliary Notation
            2.1.3 Vectors 
        2.2 Values
            2.2.1 Bytes
            2.2.2 Integers
            2.2.3 Floating-Point
            2.2.4 Names 
        2.3 Types
            2.3.1 Value Types
            2.3.2 Result Types
            2.3.3 Function Types
            2.3.4 Limits
            2.3.5 Memory Types
            2.3.6 Table Types
            2.3.7 Global Types
            2.3.8 External Types 
        2.4 Instructions
            2.4.1 Numeric Instructions
            2.4.2 Parametric Instructions
            2.4.3 Variable Instructions
            2.4.4 Memory Instructions
            2.4.5 Control Instructions
            2.4.6 Expressions 
        2.5 Modules
            2.5.1 Indices
            2.5.2 Types
            2.5.3 Functions
            2.5.4 Tables
            2.5.5 Memories
            2.5.6 Globals
            2.5.7 Element Segments
            2.5.8 Data Segments
            2.5.9 Start Function
            2.5.10 Exports
            2.5.11 Imports 
    3 Validation
        3.1 Conventions
            3.1.1 Contexts
            3.1.2 Prose Notation
            3.1.3 Formal Notation 
        3.2 Types
            3.2.1 Limits
            3.2.2 Block Types
            3.2.3 Function Types
            3.2.4 Table Types
            3.2.5 Memory Types
            3.2.6 Global Types
            3.2.7 External Types 
        3.3 Instructions
            3.3.1 Numeric Instructions
            3.3.2 Parametric Instructions
            3.3.3 Variable Instructions
            3.3.4 Memory Instructions
            3.3.5 Control Instructions
            3.3.6 Instruction Sequences
            3.3.7 Expressions 
        3.4 Modules
            3.4.1 Functions
            3.4.2 Tables
            3.4.3 Memories
            3.4.4 Globals
            3.4.5 Element Segments
            3.4.6 Data Segments
            3.4.7 Start Function
            3.4.8 Exports
            3.4.9 Imports
            3.4.10 Modules 
    4 Execution
        4.1 Conventions
            4.1.1 Prose Notation
            4.1.2 Formal Notation 
        4.2 Runtime Structure
            4.2.1 Values
            4.2.2 Results
            4.2.3 Store
            4.2.4 Addresses
            4.2.5 Module Instances
            4.2.6 Function Instances
            4.2.7 Table Instances
            4.2.8 Memory Instances
            4.2.9 Global Instances
            4.2.10 Export Instances
            4.2.11 External Values
            4.2.12 Stack
            4.2.13 Administrative Instructions 
        4.3 Numerics
            4.3.1 Representations
            4.3.2 Integer Operations
            4.3.3 Floating-Point Operations
            4.3.4 Conversions 
        4.4 Instructions
            4.4.1 Numeric Instructions
            4.4.2 Parametric Instructions
            4.4.3 Variable Instructions
            4.4.4 Memory Instructions
            4.4.5 Control Instructions
            4.4.6 Blocks
            4.4.7 Function Calls
            4.4.8 Expressions 
        4.5 Modules
            4.5.1 External Typing
            4.5.2 Import Matching
            4.5.3 Allocation
            4.5.4 Instantiation
            4.5.5 Invocation 
    5 Binary Format
        5.1 Conventions
            5.1.1 Grammar
            5.1.2 Auxiliary Notation
            5.1.3 Vectors 
        5.2 Values
            5.2.1 Bytes
            5.2.2 Integers
            5.2.3 Floating-Point
            5.2.4 Names 
        5.3 Types
            5.3.1 Value Types
            5.3.2 Result Types
            5.3.3 Function Types
            5.3.4 Limits
            5.3.5 Memory Types
            5.3.6 Table Types
            5.3.7 Global Types 
        5.4 Instructions
            5.4.1 Control Instructions
            5.4.2 Parametric Instructions
            5.4.3 Variable Instructions
            5.4.4 Memory Instructions
            5.4.5 Numeric Instructions
            5.4.6 Expressions 
        5.5 Modules
            5.5.1 Indices
            5.5.2 Sections
            5.5.3 Custom Section
            5.5.4 Type Section
            5.5.5 Import Section
            5.5.6 Function Section
            5.5.7 Table Section
            5.5.8 Memory Section
            5.5.9 Global Section
            5.5.10 Export Section
            5.5.11 Start Section
            5.5.12 Element Section
            5.5.13 Code Section
            5.5.14 Data Section
            5.5.15 Modules 
    6 Text Format
        6.1 Conventions
            6.1.1 Grammar
            6.1.2 Abbreviations
            6.1.3 Contexts
            6.1.4 Vectors 
        6.2 Lexical Format
            6.2.1 Characters
            6.2.2 Tokens
            6.2.3 White Space
            6.2.4 Comments 
        6.3 Values
            6.3.1 Integers
            6.3.2 Floating-Point
            6.3.3 Strings
            6.3.4 Names
            6.3.5 Identifiers 
        6.4 Types
            6.4.1 Value Types
            6.4.2 Function Types
            6.4.3 Limits
            6.4.4 Memory Types
            6.4.5 Table Types
            6.4.6 Global Types 
        6.5 Instructions
            6.5.1 Labels
            6.5.2 Control Instructions
            6.5.3 Parametric Instructions
            6.5.4 Variable Instructions
            6.5.5 Memory Instructions
            6.5.6 Numeric Instructions
            6.5.7 Folded Instructions
            6.5.8 Expressions 
        6.6 Modules
            6.6.1 Indices
            6.6.2 Types
            6.6.3 Type Uses
            6.6.4 Imports
            6.6.5 Functions
            6.6.6 Tables
            6.6.7 Memories
            6.6.8 Globals
            6.6.9 Exports
            6.6.10 Start Function
            6.6.11 Element Segments
            6.6.12 Data Segments
            6.6.13 Modules 
    A Appendix
        A.1 Embedding
            Types
            Errors
            Pre- and Post-Conditions
            Store
            Modules
            Module Instances
            Functions
            Tables
            Memories
            Globals 
        A.2 Implementation Limitations
            Syntactic Limits
            Validation
            Execution 
        A.3 Validation Algorithm
            Data Structures
            Validation of Opcode Sequences 
        A.4 Custom Sections
            Name Section 
        A.5 Soundness
            Values and Results
            Store Validity
            Configuration Validity
            Administrative Instructions
            Store Extension
            Theorems 
        A.6 Index of Types
        A.7 Index of Instructions
        A.8 Index of Semantic Rules
            Typing of Static Constructs
            Typing of Runtime Constructs
            Constantness
            Import Matching
            Store Extension
            Execution 
    Conformance
        Document conventions 
    References
        Normative References 

WebAssembly Specification
Release 1.0 (Draft, Apr 09, 2020)
Editor: Andreas Rossberg
Latest Draft: http://webassembly.github.io/spec/core/
Issue Tracker: http://github.com/webassembly/spec/issues/
1. Introduction
1.1. Introduction

WebAssembly (abbreviated Wasm 1) is a safe, portable, low-level code format designed for efficient execution and compact representation. Its main goal is to enable high performance applications on the Web, but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well.

WebAssembly is an open standard developed by a W3C Community Group.

This document describes version 1.0 of the core WebAssembly standard. It is intended that it will be superseded by new incremental releases with additional features in the future.
1.1.1. Design Goals

The design goals of WebAssembly are the following:

    Fast, safe, and portable semantics:

        Fast: executes with near native code performance, taking advantage of capabilities common to all contemporary hardware.

        Safe: code is validated and executes in a memory-safe 2, sandboxed environment preventing data corruption or security breaches.

        Well-defined: fully and precisely defines valid programs and their behavior in a way that is easy to reason about informally and formally.

        Hardware-independent: can be compiled on all modern architectures, desktop or mobile devices and embedded systems alike.

        Language-independent: does not privilege any particular language, programming model, or object model.

        Platform-independent: can be embedded in browsers, run as a stand-alone VM, or integrated in other environments.

        Open: programs can interoperate with their environment in a simple and universal manner.

    Efficient and portable representation:

        Compact: has a binary format that is fast to transmit by being smaller than typical text or native code formats.

        Modular: programs can be split up in smaller parts that can be transmitted, cached, and consumed separately.

        Efficient: can be decoded, validated, and compiled in a fast single pass, equally with either just-in-time (JIT) or ahead-of-time (AOT) compilation.

        Streamable: allows decoding, validation, and compilation to begin as soon as possible, before all data has been seen.

        Parallelizable: allows decoding, validation, and compilation to be split into many independent parallel tasks.

        Portable: makes no architectural assumptions that are not broadly supported across modern hardware.

WebAssembly code is also intended to be easy to inspect and debug, especially in environments like web browsers, but such features are beyond the scope of this specification.

1

    A contraction of “WebAssembly”, not an acronym, hence not using all-caps.
2

    No program can break WebAssembly’s memory model. Of course, it cannot guarantee that an unsafe language compiling to WebAssembly does not corrupt its own memory layout, e.g. inside WebAssembly’s linear memory.

1.1.2. Scope

At its core, WebAssembly is a virtual instruction set architecture (virtual ISA). As such, it has many use cases and can be embedded in many different environments. To encompass their variety and enable maximum reuse, the WebAssembly specification is split and layered into several documents.

This document is concerned with the core ISA layer of WebAssembly. It defines the instruction set, binary encoding, validation, and execution semantics, as well as a textual representation. It does not, however, define how WebAssembly programs can interact with a specific environment they execute in, nor how they are invoked from such an environment.

Instead, this specification is complemented by additional documents defining interfaces to specific embedding environments such as the Web. These will each define a WebAssembly application programming interface (API) suitable for a given environment.
1.1.3. Security Considerations

WebAssembly provides no ambient access to the computing environment in which code is executed. Any interaction with the environment, such as I/O, access to resources, or operating system calls, can only be performed by invoking functions provided by the embedder and imported into a WebAssembly module. An embedder can establish security policies suitable for a respective environment by controlling or limiting which functional capabilities it makes available for import. Such considerations are an embedder’s responsibility and the subject of API definitions for a specific environment.

Because WebAssembly is designed to be translated into machine code running directly on the host’s hardware, it is potentially vulnerable to side channel attacks on the hardware level. In environments where this is a concern, an embedder may have to put suitable mitigations into place to isolate WebAssembly computations.
1.1.4. Dependencies

WebAssembly depends on two existing standards:

    [IEEE-754-2019], for the representation of floating-point data and the semantics of respective numeric operations.

    [UNICODE], for the representation of import/export names and the text format.

However, to make this specification self-contained, relevant aspects of the aforementioned standards are defined and formalized as part of this specification, such as the binary representation and rounding of floating-point values, and the value range and UTF-8 encoding of Unicode characters.

Note

The aforementioned standards are the authoritative source of all respective definitions. Formalizations given in this specification are intended to match these definitions. Any discrepancy in the syntax or semantics described is to be considered an error.
1.2. Overview
1.2.1. Concepts

WebAssembly encodes a low-level, assembly-like programming language. This language is structured around the following concepts.

Values

    WebAssembly provides only four basic value types. These are integers and [IEEE-754-2019] numbers, each in 32 and 64 bit width. 32 bit integers also serve as Booleans and as memory addresses. The usual operations on these types are available, including the full matrix of conversions between them. There is no distinction between signed and unsigned integer types. Instead, integers are interpreted by respective operations as either unsigned or signed in two’s complement representation.

Instructions

    The computational model of WebAssembly is based on a stack machine. Code consists of sequences of instructions that are executed in order. Instructions manipulate values on an implicit operand stack 1 and fall into two main categories. Simple instructions perform basic operations on data. They pop arguments from the operand stack and push results back to it. Control instructions alter control flow. Control flow is structured, meaning it is expressed with well-nested constructs such as blocks, loops, and conditionals. Branches can only target such constructs.

Traps

    Under some conditions, certain instructions may produce a trap, which immediately aborts execution. Traps cannot be handled by WebAssembly code, but are reported to the outside environment, where they typically can be caught.

Functions

    Code is organized into separate functions. Each function takes a sequence of values as parameters and returns a sequence of values as results. 2 Functions can call each other, including recursively, resulting in an implicit call stack that cannot be accessed directly. Functions may also declare mutable local variables that are usable as virtual registers.

Tables

    A table is an array of opaque values of a particular element type. It allows programs to select such values indirectly through a dynamic index operand. Currently, the only available element type is an untyped function reference. Thereby, a program can call functions indirectly through a dynamic index into a table. For example, this allows emulating function pointers by way of table indices.

Linear Memory

    A linear memory is a contiguous, mutable array of raw bytes. Such a memory is created with an initial size but can be grown dynamically. A program can load and store values from/to a linear memory at any byte address (including unaligned). Integer loads and stores can specify a storage size which is smaller than the size of the respective value type. A trap occurs if an access is not within the bounds of the current memory size.

Modules

    A WebAssembly binary takes the form of a module that contains definitions for functions, tables, and linear memories, as well as mutable or immutable global variables. Definitions can also be imported, specifying a module/name pair and a suitable type. Each definition can optionally be exported under one or more names. In addition to definitions, modules can define initialization data for their memories or tables that takes the form of segments copied to given offsets. They can also define a start function that is automatically executed.

Embedder

    A WebAssembly implementation will typically be embedded into a host environment. This environment defines how loading of modules is initiated, how imports are provided (including host-side definitions), and how exports can be accessed. However, the details of any particular embedding are beyond the scope of this specification, and will instead be provided by complementary, environment-specific API definitions.

1

    In practice, implementations need not maintain an actual operand stack. Instead, the stack can be viewed as a set of anonymous registers that are implicitly referenced by instructions. The type system ensures that the stack height, and thus any referenced register, is always known statically.
2

    In the current version of WebAssembly, there may be at most one result value.

1.2.2. Semantic Phases

Conceptually, the semantics of WebAssembly is divided into three phases. For each part of the language, the specification specifies each of them.

Decoding

    WebAssembly modules are distributed in a binary format. Decoding processes that format and converts it into an internal representation of a module. In this specification, this representation is modelled by abstract syntax, but a real implementation could compile directly to machine code instead.

Validation

    A decoded module has to be valid. Validation checks a number of well-formedness conditions to guarantee that the module is meaningful and safe. In particular, it performs type checking of functions and the instruction sequences in their bodies, ensuring for example that the operand stack is used consistently.

Execution

    Finally, a valid module can be executed. Execution can be further divided into two phases:

    Instantiation. A module instance is the dynamic representation of a module, complete with its own state and execution stack. Instantiation executes the module body itself, given definitions for all its imports. It initializes globals, memories and tables and invokes the module’s start function if defined. It returns the instances of the module’s exports.

    Invocation. Once instantiated, further WebAssembly computations can be initiated by invoking an exported function on a module instance. Given the required arguments, that executes the respective function and returns its results.

    Instantiation and invocation are operations within the embedding environment.

2. Structure
2.1. Conventions

WebAssembly is a programming language that has multiple concrete representations (its binary format and the text format). Both map to a common structure. For conciseness, this structure is described in the form of an abstract syntax. All parts of this specification are defined in terms of this abstract syntax.
2.1.1. Grammar Notation

The following conventions are adopted in defining grammar rules for abstract syntax.

    Terminal symbols (atoms) are written in sans-serif font: i32,end.

    Nonterminal symbols are written in italic font: valtype,instr.

    An is a sequence of n≥0 iterations of A.

    A∗ is a possibly empty sequence of iterations of A. (This is a shorthand for An used where n is not relevant.)

    A+ is a non-empty sequence of iterations of A. (This is a shorthand for An where n≥1.)

    A? is an optional occurrence of A. (This is a shorthand for An where n≤1.)

    Productions are written sym::=A1​ ∣ … ∣ An​.

    Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, sym::=A1​ ∣ …, and starting continuations with ellipses, sym::=… ∣ A2​.

    Some productions are augmented with side conditions in parentheses, “(ifcondition)”, that provide a shorthand for a combinatorial expansion of the production into many separate cases.

2.1.2. Auxiliary Notation

When dealing with syntactic constructs the following notation is also used:

    ϵ denotes the empty sequence.

    ∣s∣ denotes the length of a sequence s.

    s[i] denotes the i-th element of a sequence s, starting from 0.

    s[i:n] denotes the sub-sequence s[i] … s[i+n−1] of a sequence s.

    swith[i]=A denotes the same sequence as s, except that the i-th element is replaced with A.

    swith[i:n]=An denotes the same sequence as s, except that the sub-sequence s[i:n] is replaced with An.

    concat(s∗) denotes the flat sequence formed by concatenating all sequences si​ in s∗.

Moreover, the following conventions are employed:

    The notation xn, where x is a non-terminal symbol, is treated as a meta variable ranging over respective sequences of x (similarly for x∗, x+, x?).

    When given a sequence xn, then the occurrences of x in a sequence written (A1​ x A2​)n are assumed to be in point-wise correspondence with xn (similarly for x∗, x+, x?). This implicitly expresses a form of mapping syntactic constructions over a sequence.

Productions of the following form are interpreted as records that map a fixed set of fields fieldi​ to “values” Ai​, respectively:
r ::= {field1​ A1​,field2​ A2​,…}

The following notation is adopted for manipulating such records:

    r.field denotes the contents of the field component of r.

    rwithfield=A denotes the same record as r, except that the contents of the field component is replaced with A.

    r1​⊕r2​ denotes the composition of two records with the same fields of sequences by appending each sequence point-wise:
    {field1​A1∗​,field2​A2∗​,…}⊕{field1​B1∗​,field2​B2∗​,…}={field1​A1∗​ B1∗​,field2​A2∗​ B2∗​,…}

    ⨁r∗ denotes the composition of a sequence of records, respectively; if the sequence is empty, then all fields of the resulting record are empty.

The update notation for sequences and records generalizes recursively to nested components accessed by “paths” pth::=([…]∣.field)+:

    swith[i]pth=A is short for swith[i]=(s[i]withpth=A).

    rwithfieldpth=A is short for rwithfield=(r.fieldwithpth=A).

where rwith .field=A is shortened to rwithfield=A.
2.1.3. Vectors

Vectors are bounded sequences of the form An (or A∗), where the A can either be values or complex constructions. A vector can have at most 232−1 elements.
​vec(A)​::=​An​(ifn<232)​​
2.2. Values

WebAssembly programs operate on primitive numeric values. Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.
2.2.1. Bytes

The simplest form of value are raw uninterpreted bytes. In the abstract syntax they are represented as hexadecimal literals.
​byte​::=​0x00 ∣ … ∣ 0xFF​​
2.2.1.1. Conventions

    The meta variable b ranges over bytes.

    Bytes are sometimes interpreted as natural numbers n<256.

2.2.2. Integers

Different classes of integers with different value ranges are distinguished by their bit width N and by whether they are unsigned or signed.
​uNsNiN​::=::=::=​0 ∣ 1 ∣ … ∣ 2N−1−2N−1 ∣ … ∣ −1 ∣ 0 ∣ 1 ∣ … ∣ 2N−1−1uN​​

The latter class defines uninterpreted integers, whose signedness interpretation can vary depending on context. In the abstract syntax, they are represented as unsigned values. However, some operations convert them to signed based on a two’s complement interpretation.

Note

The main integer types occurring in this specification are u32, u64, s32, s64, i8, i16, i32, i64. However, other sizes occur as auxiliary constructions, e.g., in the definition of floating-point numbers.
2.2.2.1. Conventions

    The meta variables m,n,i range over integers.

    Numbers may be denoted by simple arithmetics, as in the grammar above. In order to distinguish arithmetics like 2N from sequences like (1)N, the latter is distinguished with parentheses.

2.2.3. Floating-Point

Floating-point data represents 32 or 64 bit values that correspond to the respective binary formats of the [IEEE-754-2019] standard (Section 3.3).

Every value has a sign and a magnitude. Magnitudes can either be expressed as normal numbers of the form m0​.m1​m2​…mM​⋅2e, where e is the exponent and m is the significand whose most signifcant bit m0​ is 1, or as a subnormal number where the exponent is fixed to the smallest possible value and m0​ is 0; among the subnormals are positive and negative zero values. Since the significands are binary values, normals are represented in the form (1+m⋅2−M)⋅2e, where M is the bit width of m; similarly for subnormals.

Possible magnitudes also include the special values ∞ (infinity) and nan (NaN, not a number). NaN values have a payload that describes the mantissa bits in the underlying binary representation. No distinction is made between signalling and quiet NaNs.
​fNfNmag​::=::=∣∣∣​+fNmag ∣ −fNmag(1+uM⋅2−M)⋅2e(0+uM⋅2−M)⋅2e∞nan(n)​(if−2E−1+2≤e≤2E−1−1)(ife=−2E−1+2)(if1≤n<2M)​​

where M=signif(N) and E=expon(N) with
signif(32)signif(64)​==​2352​​​​expon(32)expon(64)​==​811​​

A canonical NaN is a floating-point value ±nan(canonN​) where canonN​ is a payload whose most significant bit is 1 while all others are 0:
canonN​=2signif(N)−1

An arithmetic NaN is a floating-point value ±nan(n) with n≥canonN​, such that the most significant bit is 1 while all others are arbitrary.

Note

In the abstract syntax, subnormals are distinguished by the leading 0 of the significand. The exponent of subnormals has the same value as the smallest possible exponent of a normal number. Only in the binary representation the exponent of a subnormal is encoded differently than the exponent of any normal number.
2.2.3.1. Conventions

    The meta variable z ranges over floating-point values where clear from context.

2.2.4. Names

Names are sequences of characters, which are scalar values as defined by [UNICODE] (Section 2.4).
​namechar​::=::=​char∗(if∣utf8(char∗)∣<232)U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​​

Due to the limitations of the binary format, the length of a name is bounded by the length of its UTF-8 encoding.
2.2.4.1. Convention

    Characters (Unicode scalar values) are sometimes used interchangeably with natural numbers n<1114112.

2.3. Types

Various entities in WebAssembly are classified by types. Types are checked during validation, instantiation, and possibly execution.
2.3.1. Value Types

Value types classify the individual values that WebAssembly code can compute with and the values that a variable accepts.
​valtype​::=​i32 ∣ i64 ∣ f32 ∣ f64​​

The types i32 and i64 classify 32 and 64 bit integers, respectively. Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.

The types f32 and f64 classify 32 and 64 bit floating-point data, respectively. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the [IEEE-754-2019] standard (Section 3.3).
2.3.1.1. Conventions

    The meta variable t ranges over value types where clear from context.

    The notation ∣t∣ denotes the bit width of a value type. That is, ∣i32∣=∣f32∣=32 and ∣i64∣=∣f64∣=64.

2.3.2. Result Types

Result types classify the result of executing instructions or functions, which is a sequence of values written with brackets.
​resulttype​::=​[vec(valtype)]​​
2.3.3. Function Types

Function types classify the signature of functions, mapping a vector of parameters to a vector of results. They are also used to classify the inputs and outputs of instructions.
​functype​::=​resulttype→resulttype​​
2.3.4. Limits

Limits classify the size range of resizeable storage associated with memory types and table types.
​limits​::=​{min u32,max u32?}​​

If no maximum is given, the respective storage can grow to any size.
2.3.5. Memory Types

Memory types classify linear memories and their size range.
​memtype​::=​limits​​

The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of page size.
2.3.6. Table Types

Table types classify tables over elements of element types within a size range.
​tabletypeelemtype​::=::=​limits elemtypefuncref​​

Like memories, tables are constrained by limits for their minimum and optionally maximum size. The limits are given in numbers of entries.

The element type funcref is the infinite union of all function types. A table of that type thus contains references to functions of heterogeneous type.

Note

In future versions of WebAssembly, additional element types may be introduced.
2.3.7. Global Types

Global types classify global variables, which hold a value and can either be mutable or immutable.
​globaltypemut​::=::=​mut valtypeconst ∣ var​​
2.3.8. External Types

External types classify imports and external values with their respective types.
​externtype​::=​func functype ∣ table tabletype ∣ mem memtype ∣ global globaltype​​
2.3.8.1. Conventions

The following auxiliary notation is defined for sequences of external types. It filters out entries of a specific kind in an order-preserving fashion:

    funcs(externtype∗)=[functype ∣ (func functype)∈externtype∗]

    tables(externtype∗)=[tabletype ∣ (table tabletype)∈externtype∗]

    mems(externtype∗)=[memtype ∣ (mem memtype)∈externtype∗]

    globals(externtype∗)=[globaltype ∣ (global globaltype)∈externtype∗]

2.4. Instructions

WebAssembly code consists of sequences of instructions. Its computational model is based on a stack machine in that instructions manipulate values on an implicit operand stack, consuming (popping) argument values and producing or returning (pushing) result values.

In addition to dynamic operands from the stack, some instructions also have static immediate arguments, typically indices or type annotations, which are part of the instruction itself.

Some instructions are structured in that they bracket nested sequences of instructions.

The following sections group instructions into a number of different categories.
2.4.1. Numeric Instructions

Numeric instructions provide basic operations over numeric values of specific type. These operations closely match respective operations available in hardware.
​nn,mmsxinstriunopibinopfunopfbinopitestopirelopfrelop​::=::=::=∣∣∣∣∣∣∣∣∣::=::=∣::=::=::=::=::=​32 ∣ 64u ∣ sinn.const inn ∣ fnn.const fnninn.iunop ∣ fnn.funopinn.ibinop ∣ fnn.fbinopinn.itestopinn.irelop ∣ fnn.frelopinn.extend8_s ∣ inn.extend16_s ∣ i64.extend_i32_sx ∣ i32.wrap_i64 ∣ inn.trunc_fmm_sxinn.trunc_sat_fmm_sxf32.demote_f64 ∣ f64.promote_f32 ∣ fnn.convert_imm_sxinn.reinterpret_fnn ∣ fnn.reinterpret_inn…clz ∣ ctz ∣ popcntadd ∣ sub ∣ mul ∣ div_sx ∣ rem_sxand ∣ or ∣ xor ∣ shl ∣ shr_sx ∣ rotl ∣ rotrabs ∣ neg ∣ sqrt ∣ ceil ∣ floor ∣ trunc ∣ nearestadd ∣ sub ∣ mul ∣ div ∣ min ∣ max ∣ copysigneqzeq ∣ ne ∣ lt_sx ∣ gt_sx ∣ le_sx ∣ ge_sxeq ∣ ne ∣ lt ∣ gt ∣ le ∣ ge​​

Numeric instructions are divided by value type. For each type, several subcategories can be distinguished:

    Constants: return a static constant.

    Unary Operations: consume one operand and produce one result of the respective type.

    Binary Operations: consume two operands and produce one result of the respective type.

    Tests: consume one operand of the respective type and produce a Boolean integer result.

    Comparisons: consume two operands of the respective type and produce a Boolean integer result.

    Conversions: consume a value of one type and produce a result of another (the source type of the conversion is the one after the “_”).

Some integer instructions come in two flavors, where a signedness annotation sx distinguishes whether the operands are to be interpreted as unsigned or signed integers. For the other integer instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.
2.4.1.1. Conventions

Occasionally, it is convenient to group operators together according to the following grammar shorthands:
​unopbinoptestoprelopcvtop​::=::=::=::=::=​iunop ∣ funop ∣ extendN_s ∣ ibinop ∣ fbinopitestopirelop ∣ frelopwrap ∣ extend ∣ trunc ∣ trunc_sat ∣ convert ∣ demote ∣ promote ∣ reinterpret​​
2.4.2. Parametric Instructions

Instructions in this group can operate on operands of any value type.
​instr​::=∣∣​…dropselect​​

The drop instruction simply throws away a single operand.

The select instruction selects one of its first two operands based on whether its third operand is zero or not.
2.4.3. Variable Instructions

Variable instructions are concerned with access to local or global variables.
​instr​::=∣∣∣∣∣​…local.get localidxlocal.set localidxlocal.tee localidxglobal.get globalidxglobal.set globalidx​​

These instructions get or set the values of variables, respectively. The local.tee instruction is like local.set but also returns its argument.
2.4.4. Memory Instructions

Instructions in this group are concerned with linear memory.
​memarginstr​::=::=∣∣∣∣∣∣​{offset u32,align u32}…inn.load memarg ∣ fnn.load memarginn.store memarg ∣ fnn.store memarginn.load8_sx memarg ∣ inn.load16_sx memarg ∣ i64.load32_sx memarginn.store8 memarg ∣ inn.store16 memarg ∣ i64.store32 memargmemory.sizememory.grow​​

Memory is accessed with load and store instructions for the different value types. They all take a memory immediate memarg that contains an address offset and the expected alignment (expressed as the exponent of a power of 2). Integer loads and stores can optionally specify a storage size that is smaller than the bit width of the respective value type. In the case of loads, a sign extension mode sx is then required to select appropriate behavior.

The static address offset is added to the dynamic address operand, yielding a 33 bit effective address that is the zero-based index at which the memory is accessed. All values are read and written in little endian byte order. A trap results if any of the accessed memory bytes lies outside the address range implied by the memory’s current size.

Note

Future version of WebAssembly might provide memory instructions with 64 bit address ranges.

The memory.size instruction returns the current size of a memory. The memory.grow instruction grows memory by a given delta and returns the previous size, or −1 if enough memory cannot be allocated. Both instructions operate in units of page size.

Note

In the current version of WebAssembly, all memory instructions implicitly operate on memory index 0. This restriction may be lifted in future versions.
2.4.5. Control Instructions

Instructions in this group affect the flow of control.
​blocktypeinstr​::=::=∣∣∣∣∣∣∣∣∣∣∣​typeidx ∣ valtype?…nopunreachableblock blocktype instr∗ endloop blocktype instr∗ endif blocktype instr∗ else instr∗ endbr labelidxbr_if labelidxbr_table vec(labelidx) labelidxreturncall funcidxcall_indirect typeidx​​

The nop instruction does nothing.

The unreachable instruction causes an unconditional trap.

The block, loop and if instructions are structured instructions. They bracket nested sequences of instructions, called blocks, terminated with, or separated by, end or else pseudo-instructions. As the grammar prescribes, they must be well-nested.

A structured instruction can consume input and produce output on the operand stack according to its annotated block type. It is given either as a type index that refers to a suitable function type, or as an optional value type inline, which is a shorthand for the function type []→[valtype?].

Each structured control instruction introduces an implicit label. Labels are targets for branch instructions that reference them with label indices. Unlike with other index spaces, indexing of labels is relative by nesting depth, that is, label 0 refers to the innermost structured control instruction enclosing the referring branch instruction, while increasing indices refer to those farther out. Consequently, labels can only be referenced from within the associated structured control instruction. This also implies that branches can only be directed outwards, “breaking” from the block of the control construct they target. The exact effect depends on that control construct. In case of block or if it is a forward jump, resuming execution after the matching end. In case of loop it is a backward jump to the beginning of the loop.

Note

This enforces structured control flow. Intuitively, a branch targeting a block or if behaves like a break statement in most C-like languages, while a branch targeting a loop behaves like a continue statement.

Branch instructions come in several flavors: br performs an unconditional branch, br_if performs a conditional branch, and br_table performs an indirect branch through an operand indexing into the label vector that is an immediate to the instruction, or to a default target if the operand is out of bounds. The return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function. Taking a branch unwinds the operand stack up to the height where the targeted structured control instruction was entered. However, branches may additionally consume operands themselves, which they push back on the operand stack after unwinding. Forward branches require operands according to the output of the targeted block’s type, i.e., represent the values produced by the terminated block. Backward branches require operands according to the input of the targeted block’s type, i.e., represent the values consumed by the restarted block.

The call instruction invokes another function, consuming the necessary arguments from the stack and returning the result values of the call. The call_indirect instruction calls a function indirectly through an operand indexing into a table. Since tables may contain function elements of heterogeneous type funcref, the callee is dynamically checked against the function type indexed by the instruction’s immediate, and the call aborted with a trap if it does not match.

Note

In the current version of WebAssembly, call_indirect implicitly operates on table index 0. This restriction may be lifted in future versions.
2.4.6. Expressions

Function bodies, initialization values for globals, and offsets of element or data segments are given as expressions, which are sequences of instructions terminated by an end marker.
​expr​::=​instr∗ end​​

In some places, validation restricts expressions to be constant, which limits the set of allowable instructions.
2.5. Modules

WebAssembly programs are organized into modules, which are the unit of deployment, loading, and compilation. A module collects definitions for types, functions, tables, memories, and globals. In addition, it can declare imports and exports and provide initialization logic in the form of data and element segments or a start function.
​module​::=​{​types vec(functype),funcs vec(func),tables vec(table),mems vec(mem),globals vec(global),elem vec(elem),data vec(data),start start?,imports vec(import),exports vec(export)}​​

Each of the vectors – and thus the entire module – may be empty.
2.5.1. Indices

Definitions are referenced with zero-based indices. Each class of definition has its own index space, as distinguished by the following classes.
​typeidxfuncidxtableidxmemidxglobalidxlocalidxlabelidx​::=::=::=::=::=::=::=​u32u32u32u32u32u32u32​​

The index space for functions, tables, memories and globals includes respective imports declared in the same module. The indices of these imports precede the indices of other definitions in the same index space.

The index space for locals is only accessible inside a function and includes the parameters of that function, which precede the local variables.

Label indices reference structured control instructions inside an instruction sequence.
2.5.1.1. Conventions

    The meta variable l ranges over label indices.

    The meta variables x,y range over indices in any of the other index spaces.

2.5.2. Types

The types component of a module defines a vector of function types.

All function types used in a module must be defined in this component. They are referenced by type indices.

Note

Future versions of WebAssembly may add additional forms of type definitions.
2.5.3. Functions

The funcs component of a module defines a vector of functions with the following structure:
​func​::=​{type typeidx,locals vec(valtype),body expr}​​

The type of a function declares its signature by reference to a type defined in the module. The parameters of the function are referenced through 0-based local indices in the function’s body; they are mutable.

The locals declare a vector of mutable local variables and their types. These variables are referenced through local indices in the function’s body. The index of the first local is the smallest index not referencing a parameter.

The body is an instruction sequence that upon termination must produce a stack matching the function type’s result type.

Functions are referenced through function indices, starting with the smallest index not referencing a function import.
2.5.4. Tables

The tables component of a module defines a vector of tables described by their table type:
​table​::=​{type tabletype}​​

A table is a vector of opaque values of a particular table element type. The min size in the limits of the table type specifies the initial size of that table, while its max, if present, restricts the size to which it can grow later.

Tables can be initialized through element segments.

Tables are referenced through table indices, starting with the smallest index not referencing a table import. Most constructs implicitly reference table index 0.

Note

In the current version of WebAssembly, at most one table may be defined or imported in a single module, and all constructs implicitly reference this table 0. This restriction may be lifted in future versions.
2.5.5. Memories

The mems component of a module defines a vector of linear memories (or memories for short) as described by their memory type:
​mem​::=​{type memtype}​​

A memory is a vector of raw uninterpreted bytes. The min size in the limits of the memory type specifies the initial size of that memory, while its max, if present, restricts the size to which it can grow later. Both are in units of page size.

Memories can be initialized through data segments.

Memories are referenced through memory indices, starting with the smallest index not referencing a memory import. Most constructs implicitly reference memory index 0.

Note

In the current version of WebAssembly, at most one memory may be defined or imported in a single module, and all constructs implicitly reference this memory 0. This restriction may be lifted in future versions.
2.5.6. Globals

The globals component of a module defines a vector of global variables (or globals for short):
​global​::=​{type globaltype,init expr}​​

Each global stores a single value of the given global type. Its type also specifies whether a global is immutable or mutable. Moreover, each global is initialized with an init value given by a constant initializer expression.

Globals are referenced through global indices, starting with the smallest index not referencing a global import.
2.5.7. Element Segments

The initial contents of a table is uninitialized. The elem component of a module defines a vector of element segments that initialize a subrange of a table, at a given offset, from a static vector of elements.
​elem​::=​{table tableidx,offset expr,init vec(funcidx)}​​

The offset is given by a constant expression.

Note

In the current version of WebAssembly, at most one table is allowed in a module. Consequently, the only valid tableidx is 0.
2.5.8. Data Segments

The initial contents of a memory are zero-valued bytes. The data component of a module defines a vector of data segments that initialize a range of memory, at a given offset, with a static vector of bytes.
​data​::=​{data memidx,offset expr,init vec(byte)}​​

The offset is given by a constant expression.

Note

In the current version of WebAssembly, at most one memory is allowed in a module. Consequently, the only valid memidx is 0.
2.5.9. Start Function

The start component of a module declares the function index of a start function that is automatically invoked when the module is instantiated, after tables and memories have been initialized.
​start​::=​{func funcidx}​​

Note

The start function is intended for initializing the state of a module. The module and its exports are not accessible before this initialization has completed.
2.5.10. Exports

The exports component of a module defines a set of exports that become accessible to the host environment once the module has been instantiated.
​exportexportdesc​::=::=∣∣∣​{name name,desc exportdesc}func funcidxtable tableidxmem memidxglobal globalidx​​

Each export is labeled by a unique name. Exportable definitions are functions, tables, memories, and globals, which are referenced through a respective descriptor.
2.5.10.1. Conventions

The following auxiliary notation is defined for sequences of exports, filtering out indices of a specific kind in an order-preserving fashion:

    funcs(export∗)=[funcidx ∣ func funcidx∈(export.desc)∗]

    tables(export∗)=[tableidx ∣ table tableidx∈(export.desc)∗]

    mems(export∗)=[memidx ∣ mem memidx∈(export.desc)∗]

    globals(export∗)=[globalidx ∣ global globalidx∈(export.desc)∗]

2.5.11. Imports

The imports component of a module defines a set of imports that are required for instantiation.
​importimportdesc​::=::=∣∣∣​{module name,name name,desc importdesc}func typeidxtable tabletypemem memtypeglobal globaltype​​

Each import is labeled by a two-level name space, consisting of a module name and a name for an entity within that module. Importable definitions are functions, tables, memories, and globals. Each import is specified by a descriptor with a respective type that a definition provided during instantiation is required to match.

Every import defines an index in the respective index space. In each index space, the indices of imports go before the first index of any definition contained in the module itself.

Note

Unlike export names, import names are not necessarily unique. It is possible to import the same module/name pair multiple times; such imports may even have different type descriptions, including different kinds of entities. A module with such imports can still be instantiated depending on the specifics of how an embedder allows resolving and supplying imports. However, embedders are not required to support such overloading, and a WebAssembly module itself cannot implement an overloaded name.
3. Validation
3.1. Conventions

Validation checks that a WebAssembly module is well-formed. Only valid modules can be instantiated.

Validity is defined by a type system over the abstract syntax of a module and its contents. For each piece of abstract syntax, there is a typing rule that specifies the constraints that apply to it. All rules are given in two equivalent forms:

    In prose, describing the meaning in intuitive form.

    In formal notation, describing the rule in mathematical form. 1

Note

The prose and formal rules are equivalent, so that understanding of the formal notation is not required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.

In both cases, the rules are formulated in a declarative manner. That is, they only formulate the constraints, they do not define an algorithm. The skeleton of a sound and complete algorithm for type-checking instruction sequences according to this specification is provided in the appendix.
3.1.1. Contexts

Validity of an individual definition is specified relative to a context, which collects relevant information about the surrounding module and the definitions in scope:

    Types: the list of types defined in the current module.

    Functions: the list of functions declared in the current module, represented by their function type.

    Tables: the list of tables declared in the current module, represented by their table type.

    Memories: the list of memories declared in the current module, represented by their memory type.

    Globals: the list of globals declared in the current module, represented by their global type.

    Locals: the list of locals declared in the current function (including parameters), represented by their value type.

    Labels: the stack of labels accessible from the current position, represented by their result type.

    Return: the return type of the current function, represented as an optional result type that is absent when no return is allowed, as in free-standing expressions.

In other words, a context contains a sequence of suitable types for each index space, describing each defined entry in that space. Locals, labels and return type are only used for validating instructions in function bodies, and are left empty elsewhere. The label stack is the only part of the context that changes as validation of an instruction sequence proceeds.

More concretely, contexts are defined as records C with abstract syntax:
​C​::=​{​typesfuncstablesmemsglobalslocalslabelsreturn​functype∗,functype∗,tabletype∗,memtype∗,globaltype∗,valtype∗,resulttype∗,resulttype? }​​​

In addition to field access written C.field the following notation is adopted for manipulating contexts:

    When spelling out a context, empty fields are omitted.

    C,fieldA∗ denotes the same context as C but with the elements A∗ prepended to its field component sequence.

Note

We use indexing notation like C.labels[i] to look up indices in their respective index space in the context. Context extension notation C,fieldA is primarily used to locally extend relative index spaces, such as label indices. Accordingly, the notation is defined to append at the front of the respective sequence, introducing a new relative index 0 and shifting the existing ones.
3.1.2. Prose Notation

Validation is specified by stylised rules for each relevant part of the abstract syntax. The rules not only state constraints defining when a phrase is valid, they also classify it with a type. The following conventions are adopted in stating these rules.

    A phrase A is said to be “valid with type T” if and only if all constraints expressed by the respective rules are met. The form of T depends on what A is.

    Note

    For example, if A is a function, then T is a function type; for an A that is a global, T is a global type; and so on.

    The rules implicitly assume a given context C.

    In some places, this context is locally extended to a context C′ with additional entries. The formulation “Under context C′, … statement …” is adopted to express that the following statement must apply under the assumptions embodied in the extended context.

3.1.3. Formal Notation

Note

This section gives a brief explanation of the notation for specifying typing rules formally. For the interested reader, a more thorough introduction can be found in respective text books. 2

The proposition that a phrase A has a respective type T is written A:T. In general, however, typing is dependent on a context C. To express this explicitly, the complete form is a judgement C⊢A:T, which says that A:T holds under the assumptions encoded in C.

The formal typing rules use a standard approach for specifying type systems, rendering them into deduction rules. Every rule has the following general form:
conclusionpremise1​premise2​…premisen​​

Such a rule is read as a big implication: if all premises hold, then the conclusion holds. Some rules have no premises; they are axioms whose conclusion holds unconditionally. The conclusion always is a judgment C⊢A:T, and there is one respective rule for each relevant construct A of the abstract syntax.

Note

For example, the typing rule for the i32.add instruction can be given as an axiom:
C⊢i32.add:[i32 i32]→[i32]​

The instruction is always valid with type [i32 i32]→[i32] (saying that it consumes two i32 values and produces one), independent of any side conditions.

An instruction like local.get can be typed as follows:
C⊢local.get x:[]→[t]C.locals[x]=t​

Here, the premise enforces that the immediate local index x exists in the context. The instruction produces a value of its respective type t (and does not consume any values). If C.locals[x] does not exist then the premise does not hold, and the instruction is ill-typed.

Finally, a structured instruction requires a recursive rule, where the premise is itself a typing judgement:
C⊢block blocktype instr∗ end:[t1∗​]→[t2∗​]C⊢blocktype:[t1∗​]→[t2∗​]C,label[t2∗​]⊢instr∗:[t1∗​]→[t2∗​]​

A block instruction is only valid when the instruction sequence in its body is. Moreover, the result type must match the block’s annotation blocktype. If so, then the block instruction has the same type as the body. Inside the body an additional label of the corresponding result type is available, which is expressed by extending the context C with the additional label information for the premise.

1

    The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
2

    For example: Benjamin Pierce. Types and Programming Languages. The MIT Press 2002

3.2. Types

Most types are universally valid. However, restrictions apply to limits, which must be checked during validation. Moreover, block types are converted to plain function types for ease of processing.
3.2.1. Limits

Limits must have meaningful bounds that are within a given range.
3.2.1.1. {min n,max m?}

    The value of n must not be larger than k.

    If the maximum m? is not empty, then:

        Its value must not be larger than k.

        Its value must not be smaller than n.

    Then the limit is valid within range k.

⊢{min n,max m?}:kn≤k(m≤k)?(n≤m)?​
3.2.2. Block Types

Block types may be expressed in one of two forms, both of which are converted to plain function types by the following rules.
3.2.2.1. typeidx

    The type C.types[typeidx] must be defined in the context.

    Then the block type is valid as function type C.types[typeidx].

C⊢typeidx:functypeC.types[typeidx]=functype​
3.2.2.2. [valtype?]

    The block type is valid as function type []→[valtype?].

C⊢[valtype?]:[]→[valtype?]​
3.2.3. Function Types

Function types are always valid.
3.2.3.1. [t1n​]→[t2m​]

    The function type is valid.

⊢[t1∗​]→[t2∗​]ok​
3.2.4. Table Types
3.2.4.1. limits elemtype

    The limits limits must be valid within range 232.

    Then the table type is valid.

⊢limits elemtypeok⊢limits:232​
3.2.5. Memory Types
3.2.5.1. limits

    The limits limits must be valid within range 216.

    Then the memory type is valid.

⊢limitsok⊢limits:216​
3.2.6. Global Types
3.2.6.1. mut valtype

    The global type is valid.

⊢mut valtypeok​
3.2.7. External Types
3.2.7.1. func functype

    The function type functype must be valid.

    Then the external type is valid.

⊢func functypeok⊢functypeok​
3.2.7.2. table tabletype

    The table type tabletype must be valid.

    Then the external type is valid.

⊢table tabletypeok⊢tabletypeok​
3.2.7.3. mem memtype

    The memory type memtype must be valid.

    Then the external type is valid.

⊢mem memtypeok⊢memtypeok​
3.2.7.4. global globaltype

    The global type globaltype must be valid.

    Then the external type is valid.

⊢global globaltypeok⊢globaltypeok​
3.3. Instructions

Instructions are classified by function types [t1∗​]→[t2∗​] that describe how they manipulate the operand stack. The types describe the required input stack with argument values of types t1∗​ that an instruction pops off and the provided output stack with result values of types t2∗​ that it pushes back.

Note

For example, the instruction i32.add has type [i32 i32]→[i32], consuming two i32 values and producing one.

Typing extends to instruction sequences instr∗. Such a sequence has a function type [t1∗​]→[t2∗​] if the accumulative effect of executing the instructions is consuming values of types t1∗​ off the operand stack and pushing new values of types t2∗​.

For some instructions, the typing rules do not fully constrain the type, and therefore allow for multiple types. Such instructions are called polymorphic. Two degrees of polymorphism can be distinguished:

    value-polymorphic: the value type t of one or several individual operands is unconstrained. That is the case for all parametric instructions like drop and select.

    stack-polymorphic: the entire (or most of the) function type [t1∗​]→[t2∗​] of the instruction is unconstrained. That is the case for all control instructions that perform an unconditional control transfer, such as unreachable, br, br_table, and return.

In both cases, the unconstrained types or type sequences can be chosen arbitrarily, as long as they meet the constraints imposed for the surrounding parts of the program.

Note

For example, the select instruction is valid with type [t t i32]→[t], for any possible value type t. Consequently, both instruction sequences
(i32.const 1)  (i32.const 2)  (i32.const 3)  select

and
(f64.const 1.0)  (f64.const 2.0)  (i32.const 3)  select

are valid, with t in the typing of select being instantiated to i32 or f64, respectively.

The unreachable instruction is valid with type [t1∗​]→[t2∗​] for any possible sequences of value types t1∗​ and t2∗​. Consequently,
unreachable  i32.add

is valid by assuming type []→[i32 i32] for the unreachable instruction. In contrast,
unreachable  (i64.const 0)  i32.add

is invalid, because there is no possible type to pick for the unreachable instruction that would make the sequence well-typed.
3.3.1. Numeric Instructions
3.3.1.1. t.const c

    The instruction is valid with type []→[t].

C⊢t.const c:[]→[t]​
3.3.1.2. t.unop

    The instruction is valid with type [t]→[t].

C⊢t.unop:[t]→[t]​
3.3.1.3. t.binop

    The instruction is valid with type [t t]→[t].

C⊢t.binop:[t t]→[t]​
3.3.1.4. t.testop

    The instruction is valid with type [t]→[i32].

C⊢t.testop:[t]→[i32]​
3.3.1.5. t.relop

    The instruction is valid with type [t t]→[i32].

C⊢t.relop:[t t]→[i32]​
3.3.1.6. t2​.cvtop_t1​_sx?

    The instruction is valid with type [t1​]→[t2​].

C⊢t2​.cvtop_t1​_sx?:[t1​]→[t2​]​
3.3.2. Parametric Instructions
3.3.2.1. drop

    The instruction is valid with type [t]→[], for any value type t.

C⊢drop:[t]→[]​
3.3.2.2. select

    The instruction is valid with type [t t i32]→[t], for any value type t.

C⊢select:[t t i32]→[t]​

Note

Both drop and select are value-polymorphic instructions.
3.3.3. Variable Instructions
3.3.3.1. local.get x

    The local C.locals[x] must be defined in the context.

    Let t be the value type C.locals[x].

    Then the instruction is valid with type []→[t].

C⊢local.get x:[]→[t]C.locals[x]=t​
3.3.3.2. local.set x

    The local C.locals[x] must be defined in the context.

    Let t be the value type C.locals[x].

    Then the instruction is valid with type [t]→[].

C⊢local.set x:[t]→[]C.locals[x]=t​
3.3.3.3. local.tee x

    The local C.locals[x] must be defined in the context.

    Let t be the value type C.locals[x].

    Then the instruction is valid with type [t]→[t].

C⊢local.tee x:[t]→[t]C.locals[x]=t​
3.3.3.4. global.get x

    The global C.globals[x] must be defined in the context.

    Let mut t be the global type C.globals[x].

    Then the instruction is valid with type []→[t].

C⊢global.get x:[]→[t]C.globals[x]=mut t​
3.3.3.5. global.set x

    The global C.globals[x] must be defined in the context.

    Let mut t be the global type C.globals[x].

    The mutability mut must be var.

    Then the instruction is valid with type [t]→[].

C⊢global.set x:[t]→[]C.globals[x]=var t​
3.3.4. Memory Instructions
3.3.4.1. t.load memarg

    The memory C.mems[0] must be defined in the context.

    The alignment 2memarg.align must not be larger than the bit width of t divided by 8.

    Then the instruction is valid with type [i32]→[t].

C⊢t.load memarg:[i32]→[t]C.mems[0]=memtype2memarg.align≤∣t∣/8​
3.3.4.2. t.loadN_sx memarg

    The memory C.mems[0] must be defined in the context.

    The alignment 2memarg.align must not be larger than N/8.

    Then the instruction is valid with type [i32]→[t].

C⊢t.loadN_sx memarg:[i32]→[t]C.mems[0]=memtype2memarg.align≤N/8​
3.3.4.3. t.store memarg

    The memory C.mems[0] must be defined in the context.

    The alignment 2memarg.align must not be larger than the bit width of t divided by 8.

    Then the instruction is valid with type [i32 t]→[].

C⊢t.store memarg:[i32 t]→[]C.mems[0]=memtype2memarg.align≤∣t∣/8​
3.3.4.4. t.storeN memarg

    The memory C.mems[0] must be defined in the context.

    The alignment 2memarg.align must not be larger than N/8.

    Then the instruction is valid with type [i32 t]→[].

C⊢t.storeN memarg:[i32 t]→[]C.mems[0]=memtype2memarg.align≤N/8​
3.3.4.5. memory.size

    The memory C.mems[0] must be defined in the context.

    Then the instruction is valid with type []→[i32].

C⊢memory.size:[]→[i32]C.mems[0]=memtype​
3.3.4.6. memory.grow

    The memory C.mems[0] must be defined in the context.

    Then the instruction is valid with type [i32]→[i32].

C⊢memory.grow:[i32]→[i32]C.mems[0]=memtype​
3.3.5. Control Instructions
3.3.5.1. nop

    The instruction is valid with type []→[].

C⊢nop:[]→[]​
3.3.5.2. unreachable

    The instruction is valid with type [t1∗​]→[t2∗​], for any sequences of value types t1∗​ and t2∗​.

C⊢unreachable:[t1∗​]→[t2∗​]​

Note

The unreachable instruction is stack-polymorphic.
3.3.5.3. block blocktype instr∗ end

    The block type must be valid as some function type [t1∗​]→[t2∗​].

    Let C′ be the same context as C, but with the result type [t2∗​] prepended to the labels vector.

    Under context C′, the instruction sequence instr∗ must be valid with type [t1∗​]→[t2∗​].

    Then the compound instruction is valid with type [t1∗​]→[t2∗​].

C⊢block blocktype instr∗ end:[t1∗​]→[t2∗​]C⊢blocktype:[t1∗​]→[t2∗​]C,labels[t2∗​]⊢instr∗:[t1∗​]→[t2∗​]​

Note

The notation C,labels[t∗] inserts the new label type at index 0, shifting all others.
3.3.5.4. loop blocktype instr∗ end

    The block type must be valid as some function type [t1∗​]→[t2∗​].

    Let C′ be the same context as C, but with the result type [t1∗​] prepended to the labels vector.

    Under context C′, the instruction sequence instr∗ must be valid with type [t1∗​]→[t2∗​].

    Then the compound instruction is valid with type [t1∗​]→[t2∗​].

C⊢loop blocktype instr∗ end:[t1∗​]→[t2∗​]C⊢blocktype:[t1∗​]→[t2∗​]C,labels[t1∗​]⊢instr∗:[t1∗​]→[t2∗​]​

Note

The notation C,labels[t∗] inserts the new label type at index 0, shifting all others.
3.3.5.5. if blocktype instr1∗​ else instr2∗​ end

    The block type must be valid as some function type [t1∗​]→[t2∗​].

    Let C′ be the same context as C, but with the result type [t2∗​] prepended to the labels vector.

    Under context C′, the instruction sequence instr1∗​ must be valid with type [t1∗​]→[t2∗​].

    Under context C′, the instruction sequence instr2∗​ must be valid with type [t1∗​]→[t2∗​].

    Then the compound instruction is valid with type [t1∗​ i32]→[t2∗​].

C⊢if blocktype instr1∗​ else instr2∗​ end:[t1∗​ i32]→[t2∗​]C⊢blocktype:[t1∗​]→[t2∗​]C,labels[t2∗​]⊢instr1∗​:[t1∗​]→[t2∗​]C,labels[t2∗​]⊢instr2∗​:[t1∗​]→[t2∗​]​

Note

The notation C,labels[t∗] inserts the new label type at index 0, shifting all others.
3.3.5.6. br l

    The label C.labels[l] must be defined in the context.

    Let [t∗] be the result type C.labels[l].

    Then the instruction is valid with type [t1∗​ t∗]→[t2∗​], for any sequences of value types t1∗​ and t2∗​.

C⊢br l:[t1∗​ t∗]→[t2∗​]C.labels[l]=[t∗]​

Note

The label index space in the context C contains the most recent label first, so that C.labels[l] performs a relative lookup as expected.

The br instruction is stack-polymorphic.
3.3.5.7. br_if l

    The label C.labels[l] must be defined in the context.

    Let [t∗] be the result type C.labels[l].

    Then the instruction is valid with type [t∗ i32]→[t∗].

C⊢br_if l:[t∗ i32]→[t∗]C.labels[l]=[t∗]​

Note

The label index space in the context C contains the most recent label first, so that C.labels[l] performs a relative lookup as expected.
3.3.5.8. br_table l∗ lN​

    The label C.labels[lN​] must be defined in the context.

    Let [t∗] be the result type C.labels[lN​].

    For all li​ in l∗, the label C.labels[li​] must be defined in the context.

    For all li​ in l∗, C.labels[li​] must be [t∗].

    Then the instruction is valid with type [t1∗​ t∗ i32]→[t2∗​], for any sequences of value types t1∗​ and t2∗​.

C⊢br_table l∗ lN​:[t1∗​ t∗ i32]→[t2∗​](C.labels[l]=[t∗])∗C.labels[lN​]=[t∗]​

Note

The label index space in the context C contains the most recent label first, so that C.labels[li​] performs a relative lookup as expected.

The br_table instruction is stack-polymorphic.
3.3.5.9. return

    The return type C.return must not be absent in the context.

    Let [t∗] be the result type of C.return.

    Then the instruction is valid with type [t1∗​ t∗]→[t2∗​], for any sequences of value types t1∗​ and t2∗​.

C⊢return:[t1∗​ t∗]→[t2∗​]C.return=[t∗]​

Note

The return instruction is stack-polymorphic.

C.return is absent (set to ϵ) when validating an expression that is not a function body. This differs from it being set to the empty result type ([ϵ]), which is the case for functions not returning anything.
3.3.5.10. call x

    The function C.funcs[x] must be defined in the context.

    Then the instruction is valid with type C.funcs[x].

C⊢call x:[t1∗​]→[t2∗​]C.funcs[x]=[t1∗​]→[t2∗​]​
3.3.5.11. call_indirect x

    The table C.tables[0] must be defined in the context.

    Let limits elemtype be the table type C.tables[0].

    The element type elemtype must be funcref.

    The type C.types[x] must be defined in the context.

    Let [t1∗​]→[t2∗​] be the function type C.types[x].

    Then the instruction is valid with type [t1∗​ i32]→[t2∗​].

C⊢call_indirect x:[t1∗​ i32]→[t2∗​]C.tables[0]=limits funcrefC.types[x]=[t1∗​]→[t2∗​]​
3.3.6. Instruction Sequences

Typing of instruction sequences is defined recursively.
3.3.6.1. Empty Instruction Sequence: ϵ

    The empty instruction sequence is valid with type [t∗]→[t∗], for any sequence of value types t∗.

C⊢ϵ:[t∗]→[t∗]​
3.3.6.2. Non-empty Instruction Sequence: instr∗ instrN​

    The instruction sequence instr∗ must be valid with type [t1∗​]→[t2∗​], for some sequences of value types t1∗​ and t2∗​.

    The instruction instrN​ must be valid with type [t∗]→[t3∗​], for some sequences of value types t∗ and t3∗​.

    There must be a sequence of value types t0∗​, such that t2∗​=t0∗​ t∗.

    Then the combined instruction sequence is valid with type [t1∗​]→[t0∗​ t3∗​].

C⊢instr∗ instrN​:[t1∗​]→[t0∗​ t3∗​]C⊢instr∗:[t1∗​]→[t0∗​ t∗]C⊢instrN​:[t∗]→[t3∗​]​
3.3.7. Expressions

Expressions expr are classified by result types of the form [t∗].
3.3.7.1. instr∗ end

    The instruction sequence instr∗ must be valid with type []→[t∗], for some result type [t∗].

    Then the expression is valid with result type [t∗].

C⊢instr∗ end:[t∗]C⊢instr∗:[]→[t∗]​
3.3.7.2. Constant Expressions

    In a constant expression instr∗ end all instructions in instr∗ must be constant.

    A constant instruction instr must be:

        either of the form t.const c,

        or of the form global.get x, in which case C.globals[x] must be a global type of the form const t.

C⊢instr∗ endconst(C⊢instrconst)∗​
C⊢t.const cconst​C⊢global.get xconstC.globals[x]=const t​

Note

Currently, constant expressions occurring as initializers of globals are further constrained in that contained global.get instructions are only allowed to refer to imported globals. This is enforced in the validation rule for modules by constraining the context C accordingly.

The definition of constant expression may be extended in future versions of WebAssembly.
3.4. Modules

Modules are valid when all the components they contain are valid. Furthermore, most definitions are themselves classified with a suitable type.
3.4.1. Functions

Functions func are classified by function types of the form [t1∗​]→[t2∗​].
3.4.1.1. {type x,locals t∗,body expr}

    The type C.types[x] must be defined in the context.

    Let [t1∗​]→[t2∗​] be the function type C.types[x].

    Let C′ be the same context as C, but with:

        locals set to the sequence of value types t1∗​ t∗, concatenating parameters and locals,

        labels set to the singular sequence containing only result type [t2∗​].

        return set to the result type [t2∗​].

    Under the context C′, the expression expr must be valid with type [t2∗​].

    Then the function definition is valid with type [t1∗​]→[t2∗​].

C⊢{type x,locals t∗,body expr}:[t1∗​]→[t2∗​]C.types[x]=[t1∗​]→[t2∗​]C,localst1∗​ t∗,labels [t2∗​],return [t2∗​]⊢expr:[t2∗​]​
3.4.2. Tables

Tables table are classified by table types.
3.4.2.1. {type tabletype}

    The table type tabletype must be valid.

    Then the table definition is valid with type tabletype.

C⊢{type tabletype}:tabletype⊢tabletypeok​
3.4.3. Memories

Memories mem are classified by memory types.
3.4.3.1. {type memtype}

    The memory type memtype must be valid.

    Then the memory definition is valid with type memtype.

C⊢{type memtype}:memtype⊢memtypeok​
3.4.4. Globals

Globals global are classified by global types of the form mut t.
3.4.4.1. {type mut t,init expr}

    The global type mut t must be valid.

    The expression expr must be valid with result type [t].

    The expression expr must be constant.

    Then the global definition is valid with type mut t.

C⊢{type mut t,init expr}:mut t⊢mut tokC⊢expr:[t]C⊢exprconst​
3.4.5. Element Segments

Element segments elem are not classified by a type.
3.4.5.1. {table x,offset expr,init y∗}

    The table C.tables[x] must be defined in the context.

    Let limits elemtype be the table type C.tables[x].

    The element type elemtype must be funcref.

    The expression expr must be valid with result type [i32].

    The expression expr must be constant.

    For each yi​ in y∗, the function C.funcs[y] must be defined in the context.

    Then the element segment is valid.

C⊢{table x,offset expr,init y∗}okC.tables[x]=limits funcrefC⊢expr:[i32]C⊢exprconst(C.funcs[y]=functype)∗​
3.4.6. Data Segments

Data segments data are not classified by any type.
3.4.6.1. {data x,offset expr,init b∗}

    The memory C.mems[x] must be defined in the context.

    The expression expr must be valid with result type [i32].

    The expression expr must be constant.

    Then the data segment is valid.

C⊢{data x,offset expr,init b∗}okC.mems[x]=limitsC⊢expr:[i32]C⊢exprconst​
3.4.7. Start Function

Start function declarations start are not classified by any type.
3.4.7.1. {func x}

    The function C.funcs[x] must be defined in the context.

    The type of C.funcs[x] must be []→[].

    Then the start function is valid.

C⊢{func x}okC.funcs[x]=[]→[]​
3.4.8. Exports

Exports export and export descriptions exportdesc are classified by their external type.
3.4.8.1. {name name,desc exportdesc}

    The export description exportdesc must be valid with external type externtype.

    Then the export is valid with external type externtype.

C⊢{name name,desc exportdesc}:externtypeC⊢exportdesc:externtype​
3.4.8.2. func x

    The function C.funcs[x] must be defined in the context.

    Then the export description is valid with external type func C.funcs[x].

C⊢func x:func functypeC.funcs[x]=functype​
3.4.8.3. table x

    The table C.tables[x] must be defined in the context.

    Then the export description is valid with external type table C.tables[x].

C⊢table x:table tabletypeC.tables[x]=tabletype​
3.4.8.4. mem x

    The memory C.mems[x] must be defined in the context.

    Then the export description is valid with external type mem C.mems[x].

C⊢mem x:mem memtypeC.mems[x]=memtype​
3.4.8.5. global x

    The global C.globals[x] must be defined in the context.

    Then the export description is valid with external type global C.globals[x].

C⊢global x:global globaltypeC.globals[x]=globaltype​
3.4.9. Imports

Imports import and import descriptions importdesc are classified by external types.
3.4.9.1. {module name1​,name name2​,desc importdesc}

    The import description importdesc must be valid with type externtype.

    Then the import is valid with type externtype.

C⊢{module name1​,name name2​,desc importdesc}:externtypeC⊢importdesc:externtype​
3.4.9.2. func x

    The function C.types[x] must be defined in the context.

    Let [t1∗​]→[t2∗​] be the function type C.types[x].

    Then the import description is valid with type func [t1∗​]→[t2∗​].

C⊢func x:func [t1∗​]→[t2∗​]C.types[x]=[t1∗​]→[t2∗​]​
3.4.9.3. table tabletype

    The table type tabletype must be valid.

    Then the import description is valid with type table tabletype.

C⊢table tabletype:table tabletype⊢tabletypeok​
3.4.9.4. mem memtype

    The memory type memtype must be valid.

    Then the import description is valid with type mem memtype.

C⊢mem memtype:mem memtype⊢memtypeok​
3.4.9.5. global globaltype

    The global type globaltype must be valid.

    Then the import description is valid with type global globaltype.

C⊢global globaltype:global globaltype⊢globaltypeok​
3.4.10. Modules

Modules are classified by their mapping from the external types of their imports to those of their exports.

A module is entirely closed, that is, its components can only refer to definitions that appear in the module itself. Consequently, no initial context is required. Instead, the context C for validation of the module’s content is constructed from the definitions in the module.

    Let module be the module to validate.

    Let C be a context where:

        C.types is module.types,

        C.funcs is funcs(it∗) concatenated with ft∗, with the import’s external types it∗ and the internal function types ft∗ as determined below,

        C.tables is tables(it∗) concatenated with tt∗, with the import’s external types it∗ and the internal table types tt∗ as determined below,

        C.mems is mems(it∗) concatenated with mt∗, with the import’s external types it∗ and the internal memory types mt∗ as determined below,

        C.globals is globals(it∗) concatenated with gt∗, with the import’s external types it∗ and the internal global types gt∗ as determined below,

        C.locals is empty,

        C.labels is empty,

        C.return is empty.

    Let C′ be the context where C′.globals is the sequence globals(it∗) and all other fields are empty.

    Under the context C:

        For each functypei​ in module.types, the function type functypei​ must be valid.

        For each funci​ in module.funcs, the definition funci​ must be valid with a function type fti​.

        For each tablei​ in module.tables, the definition tablei​ must be valid with a table type tti​.

        For each memi​ in module.mems, the definition memi​ must be valid with a memory type mti​.

        For each globali​ in module.globals:

            Under the context C′, the definition globali​ must be valid with a global type gti​.

        For each elemi​ in module.elem, the segment elemi​ must be valid.

        For each datai​ in module.data, the segment datai​ must be valid.

        If module.start is non-empty, then module.start must be valid.

        For each importi​ in module.imports, the segment importi​ must be valid with an external type iti​.

        For each exporti​ in module.exports, the segment exporti​ must be valid with external type eti​.

    The length of C.tables must not be larger than 1.

    The length of C.mems must not be larger than 1.

    All export names exporti​.name must be different.

    Let ft∗ be the concatenation of the internal function types fti​, in index order.

    Let tt∗ be the concatenation of the internal table types tti​, in index order.

    Let mt∗ be the concatenation of the internal memory types mti​, in index order.

    Let gt∗ be the concatenation of the internal global types gti​, in index order.

    Let it∗ be the concatenation of external types iti​ of the imports, in index order.

    Let et∗ be the concatenation of external types eti​ of the exports, in index order.

    Then the module is valid with external types it∗→et∗.

⊢{types functype∗,funcs func∗,tables table∗,mems mem∗,globals global∗,elem elem∗,data data∗,start start?,imports import∗,exports export∗}:it∗→et∗​(⊢functypeok)∗(C⊢func:ft)∗(C⊢table:tt)∗(C⊢mem:mt)∗(C′⊢global:gt)∗(C⊢elemok)∗(C⊢dataok)∗(C⊢startok)?(C⊢import:it)∗(C⊢export:et)∗ift∗=funcs(it∗)itt∗=tables(it∗)imt∗=mems(it∗)igt∗=globals(it∗)C={types functype∗,funcs ift∗ ft∗,tables itt∗ tt∗,mems imt∗ mt∗,globals igt∗ gt∗}C′={globals igt∗}∣C.tables∣≤1∣C.mems∣≤1(export.name)∗ disjoint​​​

Note

Most definitions in a module – particularly functions – are mutually recursive. Consequently, the definition of the context C in this rule is recursive: it depends on the outcome of validation of the function, table, memory, and global definitions contained in the module, which itself depends on C. However, this recursion is just a specification device. All types needed to construct C can easily be determined from a simple pre-pass over the module that does not perform any actual validation.

Globals, however, are not recursive. The effect of defining the limited context C′ for validating the module’s globals is that their initialization expressions can only access imported globals and nothing else.

Note

The restriction on the number of tables and memories may be lifted in future versions of WebAssembly.
4. Execution
4.1. Conventions

WebAssembly code is executed when instantiating a module or invoking an exported function on the resulting module instance.

Execution behavior is defined in terms of an abstract machine that models the program state. It includes a stack, which records operand values and control constructs, and an abstract store containing global state.

For each instruction, there is a rule that specifies the effect of its execution on the program state. Furthermore, there are rules describing the instantiation of a module. As with validation, all rules are given in two equivalent forms:

    In prose, describing the execution in intuitive form.

    In formal notation, describing the rule in mathematical form. 1

Note

As with validation, the prose and formal rules are equivalent, so that understanding of the formal notation is not required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.
4.1.1. Prose Notation

Execution is specified by stylised, step-wise rules for each instruction of the abstract syntax. The following conventions are adopted in stating these rules.

    The execution rules implicitly assume a given store S.

    The execution rules also assume the presence of an implicit stack that is modified by pushing or popping values, labels, and frames.

    Certain rules require the stack to contain at least one frame. The most recent frame is referred to as the current frame.

    Both the store and the current frame are mutated by replacing some of their components. Such replacement is assumed to apply globally.

    The execution of an instruction may trap, in which case the entire computation is aborted and no further modifications to the store are performed by it. (Other computations can still be initiated afterwards.)

    The execution of an instruction may also end in a jump to a designated target, which defines the next instruction to execute.

    Execution can enter and exit instruction sequences that form blocks.

    Instruction sequences are implicitly executed in order, unless a trap or jump occurs.

    In various places the rules contain assertions expressing crucial invariants about the program state.

4.1.2. Formal Notation

Note

This section gives a brief explanation of the notation for specifying execution formally. For the interested reader, a more thorough introduction can be found in respective text books. 2

The formal execution rules use a standard approach for specifying operational semantics, rendering them into reduction rules. Every rule has the following general form:
configuration↪configuration

A configuration is a syntactic description of a program state. Each rule specifies one step of execution. As long as there is at most one reduction rule applicable to a given configuration, reduction – and thereby execution – is deterministic. WebAssembly has only very few exceptions to this, which are noted explicitly in this specification.

For WebAssembly, a configuration typically is a tuple (S;F;instr∗) consisting of the current store S, the call frame F of the current function, and the sequence of instructions that is to be executed. (A more precise definition is given later.)

To avoid unnecessary clutter, the store S and the frame F are omitted from reduction rules that do not touch them.

There is no separate representation of the stack. Instead, it is conveniently represented as part of the configuration’s instruction sequence. In particular, values are defined to coincide with const instructions, and a sequence of const instructions can be interpreted as an operand “stack” that grows to the right.

Note

For example, the reduction rule for the i32.add instruction can be given as follows:
(i32.const n1​) (i32.const n2​) i32.add↪(i32.const (n1​+n2​)mod232)

Per this rule, two const instructions and the add instruction itself are removed from the instruction stream and replaced with one new const instruction. This can be interpreted as popping two value off the stack and pushing the result.

When no result is produced, an instruction reduces to the empty sequence:
nop↪ϵ

Labels and frames are similarly defined to be part of an instruction sequence.

The order of reduction is determined by the definition of an appropriate evaluation context.

Reduction terminates when no more reduction rules are applicable. Soundness of the WebAssembly type system guarantees that this is only the case when the original instruction sequence has either been reduced to a sequence of const instructions, which can be interpreted as the values of the resulting operand stack, or if a trap occurred.

Note

For example, the following instruction sequence,
(f64.const x1​) (f64.const x2​) f64.neg (f64.const x3​) f64.add f64.mul

terminates after three steps:
↪↪↪​(f64.const x1​) (f64.const x2​) f64.neg (f64.const x3​) f64.add f64.mul(f64.const x1​) (f64.const x4​) (f64.const x3​) f64.add f64.mul(f64.const x1​) (f64.const x5​) f64.mul(f64.const x6​)​​

where x4​=−x2​ and x5​=−x2​+x3​ and x6​=x1​⋅(−x2​+x3​).

1

    The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
2

    For example: Benjamin Pierce. Types and Programming Languages. The MIT Press 2002

4.2. Runtime Structure

Store, stack, and other runtime structure forming the WebAssembly abstract machine, such as values or module instances, are made precise in terms of additional auxiliary syntax.
4.2.1. Values

WebAssembly computations manipulate values of the four basic value types: integers and floating-point data of 32 or 64 bit width each, respectively.

In most places of the semantics, values of different types can occur. In order to avoid ambiguities, values are therefore represented with an abstract syntax that makes their type explicit. It is convenient to reuse the same notation as for the const instructions producing them:
​val​::=∣∣∣​i32.const i32i64.const i64f32.const f32f64.const f64​​
4.2.2. Results

A result is the outcome of a computation. It is either a sequence of values or a trap.
​result​::=∣​val∗trap​​

Note

In the current version of WebAssembly, a result can consist of at most one value.
4.2.3. Store

The store represents all global state that can be manipulated by WebAssembly programs. It consists of the runtime representation of all instances of functions, tables, memories, and globals that have been allocated during the life time of the abstract machine. 1

Syntactically, the store is defined as a record listing the existing instances of each category:
​store​::=​{ funcstablesmemsglobals​funcinst∗,tableinst∗,meminst∗,globalinst∗ }​​​

1

    In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.

4.2.3.1. Convention

    The meta variable S ranges over stores where clear from context.

4.2.4. Addresses

Function instances, table instances, memory instances, and global instances in the store are referenced with abstract addresses. These are simply indices into the respective store component.
​addrfuncaddrtableaddrmemaddrglobaladdr​::=::=::=::=::=​0 ∣ 1 ∣ 2 ∣ …addraddraddraddr​​

An embedder may assign identity to exported store objects corresponding to their addresses, even where this identity is not observable from within WebAssembly code itself (such as for function instances or immutable globals).

Note

Addresses are dynamic, globally unique references to runtime objects, in contrast to indices, which are static, module-local references to their original definitions. A memory address memaddr denotes the abstract address of a memory instance in the store, not an offset inside a memory instance.

There is no specific limit on the number of allocations of store objects, hence logical addresses can be arbitrarily large natural numbers.
4.2.5. Module Instances

A module instance is the runtime representation of a module. It is created by instantiating a module, and collects runtime representations of all entities that are imported, defined, or exported by the module.
​moduleinst​::=​{typesfuncaddrstableaddrsmemaddrsglobaladdrsexports​functype∗,funcaddr∗,tableaddr∗,memaddr∗,globaladdr∗,exportinst∗ }​​​

Each component references runtime instances corresponding to respective declarations from the original module – whether imported or defined – in the order of their static indices. Function instances, table instances, memory instances, and global instances are referenced with an indirection through their respective addresses in the store.

It is an invariant of the semantics that all export instances in a given module instance have different names.
4.2.6. Function Instances

A function instance is the runtime representation of a function. It effectively is a closure of the original function over the runtime module instance of its originating module. The module instance is used to resolve references to other definitions during execution of the function.
​funcinsthostfunc​::=∣::=​{type functype,module moduleinst,code func}{type functype,hostcode hostfunc}…​​

A host function is a function expressed outside WebAssembly but passed to a module as an import. The definition and behavior of host functions are outside the scope of this specification. For the purpose of this specification, it is assumed that when invoked, a host function behaves non-deterministically, but within certain constraints that ensure the integrity of the runtime.

Note

Function instances are immutable, and their identity is not observable by WebAssembly code. However, the embedder might provide implicit or explicit means for distinguishing their addresses.
4.2.7. Table Instances

A table instance is the runtime representation of a table. It holds a vector of function elements and an optional maximum size, if one was specified in the table type at the table’s definition site.

Each function element is either empty, representing an uninitialized table entry, or a function address. Function elements can be mutated through the execution of an element segment or by external means provided by the embedder.
​tableinstfuncelem​::=::=​{elem vec(funcelem),max u32?}funcaddr?​​

It is an invariant of the semantics that the length of the element vector never exceeds the maximum size, if present.

Note

Other table elements may be added in future versions of WebAssembly.
4.2.8. Memory Instances

A memory instance is the runtime representation of a linear memory. It holds a vector of bytes and an optional maximum size, if one was specified at the definition site of the memory.
​meminst​::=​{data vec(byte),max u32?}​​

The length of the vector always is a multiple of the WebAssembly page size, which is defined to be the constant 65536 – abbreviated 64Ki. Like in a memory type, the maximum size in a memory instance is given in units of this page size.

The bytes can be mutated through memory instructions, the execution of a data segment, or by external means provided by the embedder.

It is an invariant of the semantics that the length of the byte vector, divided by page size, never exceeds the maximum size, if present.
4.2.9. Global Instances

A global instance is the runtime representation of a global variable. It holds an individual value and a flag indicating whether it is mutable.
​globalinst​::=​{value val,mut mut}​​

The value of mutable globals can be mutated through variable instructions or by external means provided by the embedder.
4.2.10. Export Instances

An export instance is the runtime representation of an export. It defines the export’s name and the associated external value.
​exportinst​::=​{name name,value externval}​​
4.2.11. External Values

An external value is the runtime representation of an entity that can be imported or exported. It is an address denoting either a function instance, table instance, memory instance, or global instances in the shared store.
​externval​::=∣∣∣​func funcaddrtable tableaddrmem memaddrglobal globaladdr​​
4.2.11.1. Conventions

The following auxiliary notation is defined for sequences of external values. It filters out entries of a specific kind in an order-preserving fashion:

    funcs(externval∗)=[funcaddr ∣ (func funcaddr)∈externval∗]

    tables(externval∗)=[tableaddr ∣ (table tableaddr)∈externval∗]

    mems(externval∗)=[memaddr ∣ (mem memaddr)∈externval∗]

    globals(externval∗)=[globaladdr ∣ (global globaladdr)∈externval∗]

4.2.12. Stack

Besides the store, most instructions interact with an implicit stack. The stack contains three kinds of entries:

    Values: the operands of instructions.

    Labels: active structured control instructions that can be targeted by branches.

    Activations: the call frames of active function calls.

These entries can occur on the stack in any order during the execution of a program. Stack entries are described by abstract syntax as follows.

Note

It is possible to model the WebAssembly semantics using separate stacks for operands, control constructs, and calls. However, because the stacks are interdependent, additional book keeping about associated stack heights would be required. For the purpose of this specification, an interleaved representation is simpler.
4.2.12.1. Values

Values are represented by themselves.
4.2.12.2. Labels

Labels carry an argument arity n and their associated branch target, which is expressed syntactically as an instruction sequence:
​label​::=​labeln​{instr∗}​​

Intuitively, instr∗ is the continuation to execute when the branch is taken, in place of the original control construct.

Note

For example, a loop label has the form
labeln​{loop … end}

When performing a branch to this label, this executes the loop, effectively restarting it from the beginning. Conversely, a simple block label has the form
labeln​{ϵ}

When branching, the empty continuation ends the targeted block, such that execution can proceed with consecutive instructions.
4.2.12.3. Activations and Frames

Activation frames carry the return arity n of the respective function, hold the values of its locals (including arguments) in the order corresponding to their static local indices, and a reference to the function’s own module instance:
​activationframe​::=::=​framen​{frame}{locals val∗,module moduleinst}​​

The values of the locals are mutated by respective variable instructions.
4.2.12.4. Conventions

    The meta variable L ranges over labels where clear from context.

    The meta variable F ranges over frames where clear from context.

    The following auxiliary definition takes a block type and looks up the function type that it denotes in the current frame:

expandF​(typeidx)expandF​([valtype?])​==​F.module.types[typeidx][]→[valtype?]​​
4.2.13. Administrative Instructions

Note

This section is only relevant for the formal notation.

In order to express the reduction of traps, calls, and control instructions, the syntax of instructions is extended to include the following administrative instructions:
​instr​::=∣∣∣∣∣∣​…trapinvoke funcaddrinit_elem tableaddr u32 funcidx∗init_data memaddr u32 byte∗labeln​{instr∗} instr∗ endframen​{frame} instr∗ end​​

The trap instruction represents the occurrence of a trap. Traps are bubbled up through nested instruction sequences, ultimately reducing the entire program to a single trap instruction, signalling abrupt termination.

The invoke instruction represents the imminent invocation of a function instance, identified by its address. It unifies the handling of different forms of calls.

The init_elem and init_data instructions perform initialization of element and data segments during module instantiation.

Note

The reason for splitting instantiation into individual reduction steps is to provide a semantics that is compatible with future extensions like threads.

The label and frame instructions model labels and frames “on the stack”. Moreover, the administrative syntax maintains the nesting structure of the original structured control instruction or function body and their instruction sequences with an end marker. That way, the end of the inner instruction sequence is known when part of an outer sequence.

Note

For example, the reduction rule for block is:
block [tn] instr∗ end↪labeln​{ϵ} instr∗ end

This replaces the block with a label instruction, which can be interpreted as “pushing” the label on the stack. When end is reached, i.e., the inner instruction sequence has been reduced to the empty sequence – or rather, a sequence of n const instructions representing the resulting values – then the label instruction is eliminated courtesy of its own reduction rule:
labelm​{instr∗} valn end↪valn

This can be interpreted as removing the label from the stack and only leaving the locally accumulated operand values.
4.2.13.1. Block Contexts

In order to specify the reduction of branches, the following syntax of block contexts is defined, indexed by the count k of labels surrounding a hole [_] that marks the place where the next step of computation is taking place:
​B0Bk+1​::=::=​val∗ [_] instr∗val∗ labeln​{instr∗} Bk end instr∗​​

This definition allows to index active labels surrounding a branch or return instruction.

Note

For example, the reduction of a simple branch can be defined as follows:
label0​{instr∗} Bl[br l] end↪instr∗

Here, the hole [_] of the context is instantiated with a branch instruction. When a branch occurs, this rule replaces the targeted label and associated instruction sequence with the label’s continuation. The selected label is identified through the label index l, which corresponds to the number of surrounding label instructions that must be hopped over – which is exactly the count encoded in the index of a block context.
4.2.13.2. Configurations

A configuration consists of the current store and an executing thread.

A thread is a computation over instructions that operates relative to a current frame referring to the module instance in which the computation runs, i.e., where the current function originates from.
​configthread​::=::=​store;threadframe;instr∗​​

Note

The current version of WebAssembly is single-threaded, but configurations with multiple threads may be supported in the future.
4.2.13.3. Evaluation Contexts

Finally, the following definition of evaluation context and associated structural rules enable reduction inside instruction sequences and administrative forms as well as the propagation of traps:
​E​::=​[_] ∣ val∗ E instr∗ ∣ labeln​{instr∗} E end​​
S;F;E[instr∗]S;F;framen​{F′} instr∗ endS;F;E[trap]S;F;framen​{F′} trap end​↪↪↪↪​S′;F′;E[instr′∗](ifS;F;instr∗↪S′;F′;instr′∗)S′;F;framen​{F′′} instr′∗ end(ifS;F′;instr∗↪S′;F′′;instr′∗)S;F;trap(ifE​=[_])S;F;trap​​

Reduction terminates when a thread’s instruction sequence has been reduced to a result, that is, either a sequence of values or to a trap.

Note

The restriction on evaluation contexts rules out contexts like [_] and ϵ [_] ϵ for which E[trap]=trap.

For an example of reduction under evaluation contexts, consider the following instruction sequence.
(f64.const x1​) (f64.const x2​) f64.neg (f64.const x3​) f64.add f64.mul

This can be decomposed into E[(f64.const x2​) f64.neg] where
E=(f64.const x1​) [_] (f64.const x3​) f64.add f64.mul

Moreover, this is the only possible choice of evaluation context where the contents of the hole matches the left-hand side of a reduction rule.
4.3. Numerics

Numeric primitives are defined in a generic manner, by operators indexed over a bit width N.

Some operators are non-deterministic, because they can return one of several possible results (such as different NaN values). Technically, each operator thus returns a set of allowed values. For convenience, deterministic results are expressed as plain values, which are assumed to be identified with a respective singleton set.

Some operators are partial, because they are not defined on certain inputs. Technically, an empty set of results is returned for these inputs.

In formal notation, each operator is defined by equational clauses that apply in decreasing order of precedence. That is, the first clause that is applicable to the given arguments defines the result. In some cases, similar clauses are combined into one by using the notation ± or ∓. When several of these placeholders occur in a single clause, then they must be resolved consistently: either the upper sign is chosen for all of them or the lower sign.

Note

For example, the fcopysign operator is defined as follows:
fcopysignN​(±p1​,±p2​)fcopysignN​(±p1​,∓p2​)​==​±p1​∓p1​​​

This definition is to be read as a shorthand for the following expansion of each clause into two separate ones:
fcopysignN​(+p1​,+p2​)fcopysignN​(−p1​,−p2​)fcopysignN​(+p1​,−p2​)fcopysignN​(−p1​,+p2​)​====​+p1​−p1​−p1​+p1​​​

Conventions:

    The meta variable d is used to range over single bits.

    The meta variable p is used to range over (signless) magnitudes of floating-point values, including nan and ∞.

    The meta variable q is used to range over (signless) rational magnitudes, excluding nan or ∞.

    The notation f−1 denotes the inverse of a bijective function f.

    Truncation of rational values is written trunc(±q), with the usual mathematical definition:
    trunc(±q)​=​±i​(ifi∈N∧+q−1<i≤+q)​​

4.3.1. Representations

Numbers have an underlying binary representation as a sequence of bits:
bitsiN​(i)bitsfN​(z)​==​ibitsN​(i)fbitsN​(z)​​

Each of these functions is a bijection, hence they are invertible.
4.3.1.1. Integers

Integers are represented as base two unsigned numbers:
ibitsN​(i)​=​dN−1​ … d0​​(i=2N−1⋅dN−1​+⋯+20⋅d0​)​​

Boolean operators like ∧, ∨, or ⊻ are lifted to bit sequences of equal length by applying them pointwise.
4.3.1.2. Floating-Point

Floating-point values are represented in the respective binary format defined by [IEEE-754-2019] (Section 3.4):
fbitsN​(±(1+m⋅2−M)⋅2e)fbitsN​(±(0+m⋅2−M)⋅2e)fbitsN​(±∞)fbitsN​(±nan(n))fbiasN​fsign(+)fsign(−)​=======​fsign(±) ibitsE​(e+fbiasN​) ibitsM​(m)fsign(±) (0)E ibitsM​(m)fsign(±) (1)E (0)Mfsign(±) (1)E ibitsM​(n)2E−1−101​​

where M=signif(N) and E=expon(N).
4.3.1.3. Storage

When a number is stored into memory, it is converted into a sequence of bytes in little endian byte order:
bytest​(i)littleendian(ϵ)littleendian(d8 d′∗ )​===​littleendian(bitst​(i))ϵlittleendian(d′∗) ibits8−1​(d8)​​

Again these functions are invertable bijections.
4.3.2. Integer Operations
4.3.2.1. Sign Interpretation

Integer operators are defined on iN values. Operators that use a signed interpretation convert the value using the following definition, which takes the two’s complement when the value lies in the upper half of the value range (i.e., its most significant bit is 1):
signedN​(i)signedN​(i)​==​ii−2N​(0≤i<2N−1)(2N−1≤i<2N)​​

This function is bijective, and hence invertible.
4.3.2.2. Boolean Interpretation

The integer result of predicates – i.e., tests and relational operators – is defined with the help of the following auxiliary function producing the value 1 or 0 depending on a condition.
bool(C)bool(C)​==​10​(ifC)(otherwise)​​
4.3.2.3. iaddN​(i1​,i2​)

    Return the result of adding i1​ and i2​ modulo 2N.

iaddN​(i1​,i2​)​=​(i1​+i2​)mod2N​
4.3.2.4. isubN​(i1​,i2​)

    Return the result of subtracting i2​ from i1​ modulo 2N.

isubN​(i1​,i2​)​=​(i1​−i2​+2N)mod2N​
4.3.2.5. imulN​(i1​,i2​)

    Return the result of multiplying i1​ and i2​ modulo 2N.

imulN​(i1​,i2​)​=​(i1​⋅i2​)mod2N​
4.3.2.6. idiv_uN​(i1​,i2​)

    If i2​ is 0, then the result is undefined.

    Else, return the result of dividing i1​ by i2​, truncated toward zero.

idiv_uN​(i1​,0)idiv_uN​(i1​,i2​)​==​{}trunc(i1​/i2​)​​

Note

This operator is partial.
4.3.2.7. idiv_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    If j2​ is 0, then the result is undefined.

    Else if j1​ divided by j2​ is 2N−1, then the result is undefined.

    Else, return the result of dividing j1​ by j2​, truncated toward zero.

idiv_sN​(i1​,0)idiv_sN​(i1​,i2​)idiv_sN​(i1​,i2​)​===​{}{}(ifsignedN​(i1​)/signedN​(i2​)=2N−1)signedN−1​(trunc(signedN​(i1​)/signedN​(i2​)))​​

Note

This operator is partial. Besides division by 0, the result of (−2N−1)/(−1)=+2N−1 is not representable as an N-bit signed integer.
4.3.2.8. irem_uN​(i1​,i2​)

    If i2​ is 0, then the result is undefined.

    Else, return the remainder of dividing i1​ by i2​.

irem_uN​(i1​,0)irem_uN​(i1​,i2​)​==​{}i1​−i2​⋅trunc(i1​/i2​)​​

Note

This operator is partial.

As long as both operators are defined, it holds that i1​=i2​⋅idiv_u(i1​,i2​)+irem_u(i1​,i2​).
4.3.2.9. irem_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    If i2​ is 0, then the result is undefined.

    Else, return the remainder of dividing j1​ by j2​, with the sign of the dividend j1​.

irem_sN​(i1​,0)irem_sN​(i1​,i2​)​==​{}signedN−1​(j1​−j2​⋅trunc(j1​/j2​))(wherej1​=signedN​(i1​)∧j2​=signedN​(i2​))​​

Note

This operator is partial.

As long as both operators are defined, it holds that i1​=i2​⋅idiv_s(i1​,i2​)+irem_s(i1​,i2​).
4.3.2.10. iandN​(i1​,i2​)

    Return the bitwise conjunction of i1​ and i2​.

iandN​(i1​,i2​)​=​ibitsN−1​(ibitsN​(i1​)∧ibitsN​(i2​))​
4.3.2.11. iorN​(i1​,i2​)

    Return the bitwise disjunction of i1​ and i2​.

iorN​(i1​,i2​)​=​ibitsN−1​(ibitsN​(i1​)∨ibitsN​(i2​))​
4.3.2.12. ixorN​(i1​,i2​)

    Return the bitwise exclusive disjunction of i1​ and i2​.

ixorN​(i1​,i2​)​=​ibitsN−1​(ibitsN​(i1​)⊻ibitsN​(i2​))​
4.3.2.13. ishlN​(i1​,i2​)

    Let k be i2​ modulo N.

    Return the result of shifting i1​ left by k bits, modulo 2N.

ishlN​(i1​,i2​)​=​ibitsN−1​(d2N−k​ 0k)​(ifibitsN​(i1​)=d1k​ d2N−k​∧k=i2​modN)​
4.3.2.14. ishr_uN​(i1​,i2​)

    Let k be i2​ modulo N.

    Return the result of shifting i1​ right by k bits, extended with 0 bits.

ishr_uN​(i1​,i2​)​=​ibitsN−1​(0k d1N−k​)​(ifibitsN​(i1​)=d1N−k​ d2k​∧k=i2​modN)​
4.3.2.15. ishr_sN​(i1​,i2​)

    Let k be i2​ modulo N.

    Return the result of shifting i1​ right by k bits, extended with the most significant bit of the original value.

ishr_sN​(i1​,i2​)​=​ibitsN−1​(d0k+1​ d1N−k−1​)​(ifibitsN​(i1​)=d0​ d1N−k−1​ d2k​∧k=i2​modN)​
4.3.2.16. irotlN​(i1​,i2​)

    Let k be i2​ modulo N.

    Return the result of rotating i1​ left by k bits.

irotlN​(i1​,i2​)​=​ibitsN−1​(d2N−k​ d1k​)​(ifibitsN​(i1​)=d1k​ d2N−k​∧k=i2​modN)​
4.3.2.17. irotrN​(i1​,i2​)

    Let k be i2​ modulo N.

    Return the result of rotating i1​ right by k bits.

irotrN​(i1​,i2​)​=​ibitsN−1​(d2k​ d1N−k​)​(ifibitsN​(i1​)=d1N−k​ d2k​∧k=i2​modN)​
4.3.2.18. iclzN​(i)

    Return the count of leading zero bits in i; all bits are considered leading zeros if i is 0.

iclzN​(i)​=​k​(ifibitsN​(i)=0k (1 d∗)?)​
4.3.2.19. ictzN​(i)

    Return the count of trailing zero bits in i; all bits are considered trailing zeros if i is 0.

ictzN​(i)​=​k​(ifibitsN​(i)=(d∗ 1)? 0k)​
4.3.2.20. ipopcntN​(i)

    Return the count of non-zero bits in i.

ipopcntN​(i)​=​k​(ifibitsN​(i)=(0∗ 1)k 0∗)​
4.3.2.21. ieqzN​(i)

    Return 1 if i is zero, 0 otherwise.

ieqzN​(i)​=​bool(i=0)​
4.3.2.22. ieqN​(i1​,i2​)

    Return 1 if i1​ equals i2​, 0 otherwise.

ieqN​(i1​,i2​)​=​bool(i1​=i2​)​
4.3.2.23. ineN​(i1​,i2​)

    Return 1 if i1​ does not equal i2​, 0 otherwise.

ineN​(i1​,i2​)​=​bool(i1​​=i2​)​
4.3.2.24. ilt_uN​(i1​,i2​)

    Return 1 if i1​ is less than i2​, 0 otherwise.

ilt_uN​(i1​,i2​)​=​bool(i1​<i2​)​
4.3.2.25. ilt_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    Return 1 if j1​ is less than j2​, 0 otherwise.

ilt_sN​(i1​,i2​)​=​bool(signedN​(i1​)<signedN​(i2​))​
4.3.2.26. igt_uN​(i1​,i2​)

    Return 1 if i1​ is greater than i2​, 0 otherwise.

igt_uN​(i1​,i2​)​=​bool(i1​>i2​)​
4.3.2.27. igt_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    Return 1 if j1​ is greater than j2​, 0 otherwise.

igt_sN​(i1​,i2​)​=​bool(signedN​(i1​)>signedN​(i2​))​
4.3.2.28. ile_uN​(i1​,i2​)

    Return 1 if i1​ is less than or equal to i2​, 0 otherwise.

ile_uN​(i1​,i2​)​=​bool(i1​≤i2​)​
4.3.2.29. ile_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    Return 1 if j1​ is less than or equal to j2​, 0 otherwise.

ile_sN​(i1​,i2​)​=​bool(signedN​(i1​)≤signedN​(i2​))​
4.3.2.30. ige_uN​(i1​,i2​)

    Return 1 if i1​ is greater than or equal to i2​, 0 otherwise.

ige_uN​(i1​,i2​)​=​bool(i1​≥i2​)​
4.3.2.31. ige_sN​(i1​,i2​)

    Let j1​ be the signed interpretation of i1​.

    Let j2​ be the signed interpretation of i2​.

    Return 1 if j1​ is greater than or equal to j2​, 0 otherwise.

ige_sN​(i1​,i2​)​=​bool(signedN​(i1​)≥signedN​(i2​))​
4.3.2.32. iextendM_sN​(i)

    Return extendsM,N​(i).

iextendM_sN​(i)​=​extendsM,N​(i)​​
4.3.3. Floating-Point Operations

Floating-point arithmetic follows the [IEEE-754-2019] standard, with the following qualifications:

    All operators use round-to-nearest ties-to-even, except where otherwise specified. Non-default directed rounding attributes are not supported.

    Following the recommendation that operators propagate NaN payloads from their operands is permitted but not required.

    All operators use “non-stop” mode, and floating-point exceptions are not otherwise observable. In particular, neither alternate floating-point exception handling attributes nor operators on status flags are supported. There is no observable difference between quiet and signalling NaNs.

Note

Some of these limitations may be lifted in future versions of WebAssembly.
4.3.3.1. Rounding

Rounding always is round-to-nearest ties-to-even, in correspondence with [IEEE-754-2019] (Section 4.3.1).

An exact floating-point number is a rational number that is exactly representable as a floating-point number of given bit width N.

A limit number for a given floating-point bit width N is a positive or negative number whose magnitude is the smallest power of 2 that is not exactly representable as a floating-point number of width N (that magnitude is 2128 for N=32 and 21024 for N=64).

A candidate number is either an exact floating-point number or a positive or negative limit number for the given bit width N.

A candidate pair is a pair z1​,z2​ of candidate numbers, such that no candidate number exists that lies between the two.

A real number r is converted to a floating-point value of bit width N as follows:

    If r is 0, then return +0.

    Else if r is an exact floating-point number, then return r.

    Else if r greater than or equal to the positive limit, then return +∞.

    Else if r is less than or equal to the negative limit, then return −∞.

    Else if z1​ and z2​ are a candidate pair such that z1​<r<z2​, then:

        If ∣r−z1​∣<∣r−z2​∣, then let z be z1​.

        Else if ∣r−z1​∣>∣r−z2​∣, then let z be z2​.

        Else if ∣r−z1​∣=∣r−z2​∣ and the significand of z1​ is even, then let z be z1​.

        Else, let z be z2​.

    If z is 0, then:

        If r<0, then return −0.

        Else, return +0.

    Else if z is a limit number, then:

        If r<0, then return −∞.

        Else, return +∞.

    Else, return z.

floatN​(0)floatN​(r)floatN​(r)floatN​(r)floatN​(r)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)rectifyN​(r,±limitN​)rectifyN​(r,0)rectifyN​(r,0)rectifyN​(r,z)​=============​+0r+∞−∞closestN​(r,z1​,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)±∞+0(r≥0)−0(r<0)z​(ifr∈exactN​)(ifr≥+limitN​)(ifr≤−limitN​)(ifz1​<r<z2​∧(z1​,z2​)∈candidatepairN​)(if∣r−z1​∣<∣r−z2​∣)(if∣r−z1​∣>∣r−z2​∣)(if∣r−z1​∣=∣r−z2​∣∧evenN​(z1​))(if∣r−z1​∣=∣r−z2​∣∧evenN​(z2​))​​

where:
exactN​limitN​candidateN​candidatepairN​evenN​((d+m⋅2−M)⋅2e)evenN​(±limitN​)​====⇔⇔​fN∩Q22expon(N)−1exactN​∪{+limitN​,−limitN​}{(z1​,z2​)∈candidateN2​ ∣ z1​<z2​∧∀z∈candidateN​,z≤z1​∨z≥z2​}mmod2=0true​​
4.3.3.2. NaN Propagation

When the result of a floating-point operator other than fneg, fabs, or fcopysign is a NaN, then its sign is non-deterministic and the payload is computed as follows:

    If the payload of all NaN inputs to the operator is canonical (including the case that there are no NaN inputs), then the payload of the output is canonical as well.

    Otherwise the payload is picked non-deterministically among all arithmetic NaNs; that is, its most significant bit is 1 and all others are unspecified.

This non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs from a set of inputs:
nansN​{z∗}nansN​{z∗}​==​{+nan(n),−nan(n) ∣ n=canonN​}{+nan(n),−nan(n) ∣ n≥canonN​}​(if∀nan(n)∈z∗, n=canonN​)(otherwise)​​
4.3.3.3. faddN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if both z1​ and z2​ are infinities of opposite signs, then return an element of nansN​{}.

    Else if both z1​ and z2​ are infinities of equal sign, then return that infinity.

    Else if one of z1​ or z2​ is an infinity, then return that infinity.

    Else if both z1​ and z2​ are zeroes of opposite sign, then return positive zero.

    Else if both z1​ and z2​ are zeroes of equal sign, then return that zero.

    Else if one of z1​ or z2​ is a zero, then return the other operand.

    Else if both z1​ and z2​ are values with the same magnitude but opposite signs, then return positive zero.

    Else return the result of adding z1​ and z2​, rounded to the nearest representable value.

faddN​(±nan(n),z2​)faddN​(z1​,±nan(n))faddN​(±∞,∓∞)faddN​(±∞,±∞)faddN​(z1​,±∞)faddN​(±∞,z2​)faddN​(±0,∓0)faddN​(±0,±0)faddN​(z1​,±0)faddN​(±0,z2​)faddN​(±q,∓q)faddN​(z1​,z2​)​============​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}nansN​{}±∞±∞±∞+0±0z1​z2​+0floatN​(z1​+z2​)​​
4.3.3.4. fsubN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if both z1​ and z2​ are infinities of equal signs, then return an element of nansN​{}.

    Else if both z1​ and z2​ are infinities of opposite sign, then return z1​.

    Else if z1​ is an infinity, then return that infinity.

    Else if z2​ is an infinity, then return that infinity negated.

    Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.

    Else if both z1​ and z2​ are zeroes of opposite sign, then return z1​.

    Else if z2​ is a zero, then return z1​.

    Else if z1​ is a zero, then return z2​ negated.

    Else if both z1​ and z2​ are the same value, then return positive zero.

    Else return the result of subtracting z2​ from z1​, rounded to the nearest representable value.

fsubN​(±nan(n),z2​)fsubN​(z1​,±nan(n))fsubN​(±∞,±∞)fsubN​(±∞,∓∞)fsubN​(z1​,±∞)fsubN​(±∞,z2​)fsubN​(±0,±0)fsubN​(±0,∓0)fsubN​(z1​,±0)fsubN​(±0,±q2​)fsubN​(±q,±q)fsubN​(z1​,z2​)​============​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}nansN​{}±∞∓∞±∞+0±0z1​∓q2​+0floatN​(z1​−z2​)​​

Note

Up to the non-determinism regarding NaNs, it always holds that fsubN​(z1​,z2​)=faddN​(z1​,fnegN​(z2​)).
4.3.3.5. fmulN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if one of z1​ and z2​ is a zero and the other an infinity, then return an element of nansN​{}.

    Else if both z1​ and z2​ are infinities of equal sign, then return positive infinity.

    Else if both z1​ and z2​ are infinities of opposite sign, then return negative infinity.

    Else if one of z1​ or z2​ is an infinity and the other a value with equal sign, then return positive infinity.

    Else if one of z1​ or z2​ is an infinity and the other a value with opposite sign, then return negative infinity.

    Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.

    Else if both z1​ and z2​ are zeroes of opposite sign, then return negative zero.

    Else return the result of multiplying z1​ and z2​, rounded to the nearest representable value.

fmulN​(±nan(n),z2​)fmulN​(z1​,±nan(n))fmulN​(±∞,±0)fmulN​(±∞,∓0)fmulN​(±0,±∞)fmulN​(±0,∓∞)fmulN​(±∞,±∞)fmulN​(±∞,∓∞)fmulN​(±q1​,±∞)fmulN​(±q1​,∓∞)fmulN​(±∞,±q2​)fmulN​(±∞,∓q2​)fmulN​(±0,±0)fmulN​(±0,∓0)fmulN​(z1​,z2​)​===============​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}nansN​{}nansN​{}nansN​{}nansN​{}+∞−∞+∞−∞+∞−∞+0−0floatN​(z1​⋅z2​)​​
4.3.3.6. fdivN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if both z1​ and z2​ are infinities, then return an element of nansN​{}.

    Else if both z1​ and z2​ are zeroes, then return an element of nansN​{z1​,z2​}.

    Else if z1​ is an infinity and z2​ a value with equal sign, then return positive infinity.

    Else if z1​ is an infinity and z2​ a value with opposite sign, then return negative infinity.

    Else if z2​ is an infinity and z1​ a value with equal sign, then return positive zero.

    Else if z2​ is an infinity and z1​ a value with opposite sign, then return negative zero.

    Else if z1​ is a zero and z2​ a value with equal sign, then return positive zero.

    Else if z1​ is a zero and z2​ a value with opposite sign, then return negative zero.

    Else if z2​ is a zero and z1​ a value with equal sign, then return positive infinity.

    Else if z2​ is a zero and z1​ a value with opposite sign, then return negative infinity.

    Else return the result of dividing z1​ by z2​, rounded to the nearest representable value.

fdivN​(±nan(n),z2​)fdivN​(z1​,±nan(n))fdivN​(±∞,±∞)fdivN​(±∞,∓∞)fdivN​(±0,±0)fdivN​(±0,∓0)fdivN​(±∞,±q2​)fdivN​(±∞,∓q2​)fdivN​(±q1​,±∞)fdivN​(±q1​,∓∞)fdivN​(±0,±q2​)fdivN​(±0,∓q2​)fdivN​(±q1​,±0)fdivN​(±q1​,∓0)fdivN​(z1​,z2​)​===============​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}nansN​{}nansN​{}nansN​{}nansN​{}+∞−∞+0−0+0−0+∞−∞floatN​(z1​/z2​)​​
4.3.3.7. fminN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if one of z1​ or z2​ is a negative infinity, then return negative infinity.

    Else if one of z1​ or z2​ is a positive infinity, then return the other value.

    Else if both z1​ and z2​ are zeroes of opposite signs, then return negative zero.

    Else return the smaller value of z1​ and z2​.

fminN​(±nan(n),z2​)fminN​(z1​,±nan(n))fminN​(+∞,z2​)fminN​(−∞,z2​)fminN​(z1​,+∞)fminN​(z1​,−∞)fminN​(±0,∓0)fminN​(z1​,z2​)fminN​(z1​,z2​)​=========​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}z2​−∞z1​−∞−0z1​z2​​(ifz1​≤z2​)(ifz2​≤z1​)​​
4.3.3.8. fmaxN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return an element of nansN​{z1​,z2​}.

    Else if one of z1​ or z2​ is a positive infinity, then return positive infinity.

    Else if one of z1​ or z2​ is a negative infinity, then return the other value.

    Else if both z1​ and z2​ are zeroes of opposite signs, then return positive zero.

    Else return the larger value of z1​ and z2​.

fmaxN​(±nan(n),z2​)fmaxN​(z1​,±nan(n))fmaxN​(+∞,z2​)fmaxN​(−∞,z2​)fmaxN​(z1​,+∞)fmaxN​(z1​,−∞)fmaxN​(±0,∓0)fmaxN​(z1​,z2​)fmaxN​(z1​,z2​)​=========​nansN​{±nan(n),z2​}nansN​{±nan(n),z1​}+∞z2​+∞z1​+0z1​z2​​(ifz1​≥z2​)(ifz2​≥z1​)​​
4.3.3.9. fcopysignN​(z1​,z2​)

    If z1​ and z2​ have the same sign, then return z1​.

    Else return z1​ with negated sign.

fcopysignN​(±p1​,±p2​)fcopysignN​(±p1​,∓p2​)​==​±p1​∓p1​​​
4.3.3.10. fabsN​(z)

    If z is a NaN, then return z with positive sign.

    Else if z is an infinity, then return positive infinity.

    Else if z is a zero, then return positive zero.

    Else if z is a positive value, then z.

    Else return z negated.

fabsN​(±nan(n))fabsN​(±∞)fabsN​(±0)fabsN​(±q)​====​+nan(n)+∞+0+q​​
4.3.3.11. fnegN​(z)

    If z is a NaN, then return z with negated sign.

    Else if z is an infinity, then return that infinity negated.

    Else if z is a zero, then return that zero negated.

    Else return z negated.

fnegN​(±nan(n))fnegN​(±∞)fnegN​(±0)fnegN​(±q)​====​∓nan(n)∓∞∓0∓q​​
4.3.3.12. fsqrtN​(z)

    If z is a NaN, then return an element of nansN​{z}.

    Else if z has a negative sign, then return an element of nansN​{}.

    Else if z is positive infinity, then return positive infinity.

    Else if z is a zero, then return that zero.

    Else return the square root of z.

fsqrtN​(±nan(n))fsqrtN​(−∞)fsqrtN​(+∞)fsqrtN​(±0)fsqrtN​(−q)fsqrtN​(+q)​======​nansN​{±nan(n)}nansN​{}+∞±0nansN​{}floatN​(q
​)​​
4.3.3.13. fceilN​(z)

    If z is a NaN, then return an element of nansN​{z}.

    Else if z is an infinity, then return z.

    Else if z is a zero, then return z.

    Else if z is smaller than 0 but greater than −1, then return negative zero.

    Else return the smallest integral value that is not smaller than z.

fceilN​(±nan(n))fceilN​(±∞)fceilN​(±0)fceilN​(−q)fceilN​(±q)​=====​nansN​{±nan(n)}±∞±0−0floatN​(i)​(if−1<−q<0)(if±q≤i<±q+1)​​
4.3.3.14. ffloorN​(z)

    If z is a NaN, then return an element of nansN​{z}.

    Else if z is an infinity, then return z.

    Else if z is a zero, then return z.

    Else if z is greater than 0 but smaller than 1, then return positive zero.

    Else return the largest integral value that is not larger than z.

ffloorN​(±nan(n))ffloorN​(±∞)ffloorN​(±0)ffloorN​(+q)ffloorN​(±q)​=====​nansN​{±nan(n)}±∞±0+0floatN​(i)​(if0<+q<1)(if±q−1<i≤±q)​​
4.3.3.15. ftruncN​(z)

    If z is a NaN, then return an element of nansN​{z}.

    Else if z is an infinity, then return z.

    Else if z is a zero, then return z.

    Else if z is greater than 0 but smaller than 1, then return positive zero.

    Else if z is smaller than 0 but greater than −1, then return negative zero.

    Else return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.

ftruncN​(±nan(n))ftruncN​(±∞)ftruncN​(±0)ftruncN​(+q)ftruncN​(−q)ftruncN​(±q)​======​nansN​{±nan(n)}±∞±0+0−0floatN​(±i)​(if0<+q<1)(if−1<−q<0)(if+q−1<i≤+q)​​
4.3.3.16. fnearestN​(z)

    If z is a NaN, then return an element of nansN​{z}.

    Else if z is an infinity, then return z.

    Else if z is a zero, then return z.

    Else if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.

    Else if z is smaller than 0 but greater than or equal to −0.5, then return negative zero.

    Else return the integral value that is nearest to z; if two values are equally near, return the even one.

fnearestN​(±nan(n))fnearestN​(±∞)fnearestN​(±0)fnearestN​(+q)fnearestN​(−q)fnearestN​(±q)fnearestN​(±q)​=======​nansN​{±nan(n)}±∞±0+0−0floatN​(±i)floatN​(±i)​(if0<+q≤0.5)(if−0.5≤−q<0)(if∣i−q∣<0.5)(if∣i−q∣=0.5∧i even)​​
4.3.3.17. feqN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 0.

    Else if both z1​ and z2​ are zeroes, then return 1.

    Else if both z1​ and z2​ are the same value, then return 1.

    Else return 0.

feqN​(±nan(n),z2​)feqN​(z1​,±nan(n))feqN​(±0,∓0)feqN​(z1​,z2​)​====​001bool(z1​=z2​)​​
4.3.3.18. fneN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 1.

    Else if both z1​ and z2​ are zeroes, then return 0.

    Else if both z1​ and z2​ are the same value, then return 0.

    Else return 1.

fneN​(±nan(n),z2​)fneN​(z1​,±nan(n))fneN​(±0,∓0)fneN​(z1​,z2​)​====​110bool(z1​​=z2​)​​
4.3.3.19. fltN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 0.

    Else if z1​ and z2​ are the same value, then return 0.

    Else if z1​ is positive infinity, then return 0.

    Else if z1​ is negative infinity, then return 1.

    Else if z2​ is positive infinity, then return 1.

    Else if z2​ is negative infinity, then return 0.

    Else if both z1​ and z2​ are zeroes, then return 0.

    Else if z1​ is smaller than z2​, then return 1.

    Else return 0.

fltN​(±nan(n),z2​)fltN​(z1​,±nan(n))fltN​(z,z)fltN​(+∞,z2​)fltN​(−∞,z2​)fltN​(z1​,+∞)fltN​(z1​,−∞)fltN​(±0,∓0)fltN​(z1​,z2​)​=========​00001100bool(z1​<z2​)​​
4.3.3.20. fgtN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 0.

    Else if z1​ and z2​ are the same value, then return 0.

    Else if z1​ is positive infinity, then return 1.

    Else if z1​ is negative infinity, then return 0.

    Else if z2​ is positive infinity, then return 0.

    Else if z2​ is negative infinity, then return 1.

    Else if both z1​ and z2​ are zeroes, then return 0.

    Else if z1​ is larger than z2​, then return 1.

    Else return 0.

fgtN​(±nan(n),z2​)fgtN​(z1​,±nan(n))fgtN​(z,z)fgtN​(+∞,z2​)fgtN​(−∞,z2​)fgtN​(z1​,+∞)fgtN​(z1​,−∞)fgtN​(±0,∓0)fgtN​(z1​,z2​)​=========​00010010bool(z1​>z2​)​​
4.3.3.21. fleN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 0.

    Else if z1​ and z2​ are the same value, then return 1.

    Else if z1​ is positive infinity, then return 0.

    Else if z1​ is negative infinity, then return 1.

    Else if z2​ is positive infinity, then return 1.

    Else if z2​ is negative infinity, then return 0.

    Else if both z1​ and z2​ are zeroes, then return 1.

    Else if z1​ is smaller than or equal to z2​, then return 1.

    Else return 0.

fleN​(±nan(n),z2​)fleN​(z1​,±nan(n))fleN​(z,z)fleN​(+∞,z2​)fleN​(−∞,z2​)fleN​(z1​,+∞)fleN​(z1​,−∞)fleN​(±0,∓0)fleN​(z1​,z2​)​=========​00101101bool(z1​≤z2​)​​
4.3.3.22. fgeN​(z1​,z2​)

    If either z1​ or z2​ is a NaN, then return 0.

    Else if z1​ and z2​ are the same value, then return 1.

    Else if z1​ is positive infinity, then return 1.

    Else if z1​ is negative infinity, then return 0.

    Else if z2​ is positive infinity, then return 0.

    Else if z2​ is negative infinity, then return 1.

    Else if both z1​ and z2​ are zeroes, then return 1.

    Else if z1​ is smaller than or equal to z2​, then return 1.

    Else return 0.

fgeN​(±nan(n),z2​)fgeN​(z1​,±nan(n))fgeN​(z,z)fgeN​(+∞,z2​)fgeN​(−∞,z2​)fgeN​(z1​,+∞)fgeN​(z1​,−∞)fgeN​(±0,∓0)fgeN​(z1​,z2​)​=========​00110011bool(z1​≥z2​)​​
4.3.4. Conversions
4.3.4.1. extenduM,N​(i)

    Return i.

extenduM,N​(i)​=​i​​

Note

In the abstract syntax, unsigned extension just reinterprets the same value.
4.3.4.2. extendsM,N​(i)

    Let j be the signed interpretation of i of size M.

    Return the two’s complement of j relative to size N.

extendsM,N​(i)​=​signedN−1​(signedM​(i))​​
4.3.4.3. wrapM,N​(i)

    Return i modulo 2N.

wrapM,N​(i)​=​imod2N​​
4.3.4.4. truncuM,N​(z)

    If z is a NaN, then the result is undefined.

    Else if z is an infinity, then the result is undefined.

    Else if z is a number and trunc(z) is a value within range of the target type, then return that value.

    Else the result is undefined.

truncuM,N​(±nan(n))truncuM,N​(±∞)truncuM,N​(±q)truncuM,N​(±q)​====​{}{}trunc(±q){}​(if−1<trunc(±q)<2N)(otherwise)​​

Note

This operator is partial. It is not defined for NaNs, infinities, or values for which the result is out of range.
4.3.4.5. truncsM,N​(z)

    If z is a NaN, then the result is undefined.

    Else if z is an infinity, then the result is undefined.

    If z is a number and trunc(z) is a value within range of the target type, then return that value.

    Else the result is undefined.

truncsM,N​(±nan(n))truncsM,N​(±∞)truncsM,N​(±q)truncsM,N​(±q)​====​{}{}trunc(±q){}​(if−2N−1−1<trunc(±q)<2N−1)(otherwise)​​

Note

This operator is partial. It is not defined for NaNs, infinities, or values for which the result is out of range.
4.3.4.6. trunc_sat_uM,N​(z)

    If z is a NaN, then return 0.

    Else if z is negative infinity, then return 0.

    Else if z is positive infinity, then return 2N−1.

    Else if trunc(z) is less than 0, then return 0.

    Else if trunc(z) is greater than 2N−1, then return 2N−1.

    Else, return trunc(z).

trunc_sat_uM,N​(±nan(n))trunc_sat_uM,N​(−∞)trunc_sat_uM,N​(+∞)trunc_sat_uM,N​(−q)trunc_sat_uM,N​(+q)trunc_sat_uM,N​(±q)​======​002N−102N−1trunc(±q)​(iftrunc(−q)<0)(iftrunc(+q)>2N−1)(otherwise)​​
4.3.4.7. trunc_sat_sM,N​(z)

    If z is a NaN, then return 0.

    Else if z is negative infinity, then return −2N−1.

    Else if z is positive infinity, then return 2N−1−1.

    Else if trunc(z) is less than −2N−1, then return −2N−1.

    Else if trunc(z) is greater than 2N−1−1, then return 2N−1−1.

    Else, return trunc(z).

trunc_sat_sM,N​(±nan(n))trunc_sat_sM,N​(−∞)trunc_sat_sM,N​(+∞)trunc_sat_sM,N​(−q)trunc_sat_sM,N​(+q)trunc_sat_sM,N​(±q)​======​0−2N−12N−1−1−2N−12N−1−1trunc(±q)​(iftrunc(−q)<−2N−1)(iftrunc(+q)>2N−1−1)(otherwise)​​
4.3.4.8. promoteM,N​(z)

    If z is a canonical NaN, then return an element of nansN​{} (i.e., a canonical NaN of size N).

    Else if z is a NaN, then return an element of nansN​{±nan(1)} (i.e., any arithmetic NaN of size N).

    Else, return z.

promoteM,N​(±nan(n))promoteM,N​(±nan(n))promoteM,N​(z)​===​nansN​{}nansN​{+nan(1)}z​(ifn=canonN​)(otherwise)​​
4.3.4.9. demoteM,N​(z)

    If z is a canonical NaN, then return an element of nansN​{} (i.e., a canonical NaN of size N).

    Else if z is a NaN, then return an element of nansN​{±nan(1)} (i.e., any NaN of size N).

    Else if z is an infinity, then return that infinity.

    Else if z is a zero, then return that zero.

    Else, return floatN​(z).

demoteM,N​(±nan(n))demoteM,N​(±nan(n))demoteM,N​(±∞)demoteM,N​(±0)demoteM,N​(±q)​=====​nansN​{}nansN​{+nan(1)}±∞±0floatN​(±q)​(ifn=canonN​)(otherwise)​
4.3.4.10. convertuM,N​(i)

    Return floatN​(i).

convertuM,N​(i)​=​floatN​(i)​​
4.3.4.11. convertsM,N​(i)

    Let j be the signed interpretation of i.

    Return floatN​(j).

convertuM,N​(i)​=​floatN​(signedM​(i))​​
4.3.4.12. reinterprett1​,t2​​(c)

    Let d∗ be the bit sequence bitst1​​(c).

    Return the constant c′ for which bitst2​​(c′)=d∗.

reinterprett1​,t2​​(c)​=​bitst2​−1​(bitst1​​(c))​​
4.4. Instructions

WebAssembly computation is performed by executing individual instructions.
4.4.1. Numeric Instructions

Numeric instructions are defined in terms of the generic numeric operators. The mapping of numeric instructions to their underlying operators is expressed by the following definition:
opiN​(n1​,…,nk​)opfN​(z1​,…,zk​)​==​iopN​(n1​,…,nk​)fopN​(z1​,…,zk​)​​

And for conversion operators:
cvtopt1​,t2​sx?​(c)​=​cvtop∣t1​∣,∣t2​∣sx?​(c)​​

Where the underlying operators are partial, the corresponding instruction will trap when the result is not defined. Where the underlying operators are non-deterministic, because they may return one of multiple possible NaN values, so are the corresponding instructions.

Note

For example, the result of instruction i32.add applied to operands i1​,i2​ invokes addi32​(i1​,i2​), which maps to the generic iadd32​(i1​,i2​) via the above definition. Similarly, i64.trunc_f32_s applied to z invokes truncf32,i64s​(z), which maps to the generic truncs32,64​(z).
4.4.1.1. t.const c

    Push the value t.const c to the stack.

Note

No formal reduction rule is required for this instruction, since const instructions coincide with values.
4.4.1.2. t.unop

    Assert: due to validation, a value of value type t is on the top of the stack.

    Pop the value t.const c1​ from the stack.

    If unopt​(c1​) is defined, then:

        Let c be a possible result of computing unopt​(c1​).

        Push the value t.const c to the stack.

    Else:

        Trap.

(t.const c1​) t.unop(t.const c1​) t.unop​↪↪​(t.const c)trap​(ifc∈unopt​(c1​))(ifunopt​(c1​)={})​​
4.4.1.3. t.binop

    Assert: due to validation, two values of value type t are on the top of the stack.

    Pop the value t.const c2​ from the stack.

    Pop the value t.const c1​ from the stack.

    If binopt​(c1​,c2​) is defined, then:

        Let c be a possible result of computing binopt​(c1​,c2​).

        Push the value t.const c to the stack.

    Else:

        Trap.

(t.const c1​) (t.const c2​) t.binop(t.const c1​) (t.const c2​) t.binop​↪↪​(t.const c)trap​(ifc∈binopt​(c1​,c2​))(ifbinopt​(c1​,c2)={})​​
4.4.1.4. t.testop

    Assert: due to validation, a value of value type t is on the top of the stack.

    Pop the value t.const c1​ from the stack.

    Let c be the result of computing testopt​(c1​).

    Push the value i32.const c to the stack.

(t.const c1​) t.testop​↪​(i32.const c)​(ifc=testopt​(c1​))​​
4.4.1.5. t.relop

    Assert: due to validation, two values of value type t are on the top of the stack.

    Pop the value t.const c2​ from the stack.

    Pop the value t.const c1​ from the stack.

    Let c be the result of computing relopt​(c1​,c2​).

    Push the value i32.const c to the stack.

(t.const c1​) (t.const c2​) t.relop​↪​(i32.const c)​(ifc=relopt​(c1​,c2​))​​
4.4.1.6. t2​.cvtop_t1​_sx?

    Assert: due to validation, a value of value type t1​ is on the top of the stack.

    Pop the value t1​.const c1​ from the stack.

    If cvtopt1​,t2​sx?​(c1​) is defined:

        Let c2​ be a possible result of computing cvtopt1​,t2​sx?​(c1​).

        Push the value t2​.const c2​ to the stack.

    Else:

        Trap.

(t1​.const c1​) t2​.cvtop_t1​_sx?(t1​.const c1​) t2​.cvtop_t1​_sx?​↪↪​(t2​.const c2​)trap​(ifc2​∈cvtopt1​,t2​sx?​(c1​))(ifcvtopt1​,t2​sx?​(c1​)={})​​
4.4.2. Parametric Instructions
4.4.2.1. drop

    Assert: due to validation, a value is on the top of the stack.

    Pop the value val from the stack.

val  drop​↪​ϵ​
4.4.2.2. select

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const c from the stack.

    Assert: due to validation, two more values (of the same value type) are on the top of the stack.

    Pop the value val2​ from the stack.

    Pop the value val1​ from the stack.

    If c is not 0, then:

        Push the value val1​ back to the stack.

    Else:

        Push the value val2​ back to the stack.

val1​ val2​ (i32.const c) selectval1​ val2​ (i32.const c) select​↪↪​val1​val2​​(ifc​=0)(ifc=0)​​
4.4.3. Variable Instructions
4.4.3.1. local.get x

    Let F be the current frame.

    Assert: due to validation, F.locals[x] exists.

    Let val be the value F.locals[x].

    Push the value val to the stack.

F;(local.get x)​↪​F;val​(ifF.locals[x]=val)​​
4.4.3.2. local.set x

    Let F be the current frame.

    Assert: due to validation, F.locals[x] exists.

    Assert: due to validation, a value is on the top of the stack.

    Pop the value val from the stack.

    Replace F.locals[x] with the value val.

F;val (local.set x)​↪​F′;ϵ​(ifF′=Fwithlocals[x]=val)​​
4.4.3.3. local.tee x

    Assert: due to validation, a value is on the top of the stack.

    Pop the value val from the stack.

    Push the value val to the stack.

    Push the value val to the stack.

    Execute the instruction (local.set x).

val (local.tee x)​↪​val val (local.set x)​
4.4.3.4. global.get x

    Let F be the current frame.

    Assert: due to validation, F.module.globaladdrs[x] exists.

    Let a be the global address F.module.globaladdrs[x].

    Assert: due to validation, S.globals[a] exists.

    Let glob be the global instance S.globals[a].

    Let val be the value glob.value.

    Push the value val to the stack.

S;F;(global.get x)​↪​S;F;val​(ifS.globals[F.module.globaladdrs[x]].value=val)​​
4.4.3.5. global.set x

    Let F be the current frame.

    Assert: due to validation, F.module.globaladdrs[x] exists.

    Let a be the global address F.module.globaladdrs[x].

    Assert: due to validation, S.globals[a] exists.

    Let glob be the global instance S.globals[a].

    Assert: due to validation, a value is on the top of the stack.

    Pop the value val from the stack.

    Replace glob.value with the value val.

S;F;val (global.set x)​↪​S′;F;ϵ​(ifS′=Swithglobals[F.module.globaladdrs[x]].value=val)​​

Note

Validation ensures that the global is, in fact, marked as mutable.
4.4.4. Memory Instructions

Note

The alignment memarg.align in load and store instructions does not affect the semantics. It is an indication that the offset ea at which the memory is accessed is intended to satisfy the property eamod2memarg.align=0. A WebAssembly implementation can use this hint to optimize for the intended use. Unaligned access violating that property is still allowed and must succeed regardless of the annotation. However, it may be substantially slower on some hardware.
4.4.4.1. t.load memarg and t.loadN_sx memarg

    Let F be the current frame.

    Assert: due to validation, F.module.memaddrs[0] exists.

    Let a be the memory address F.module.memaddrs[0].

    Assert: due to validation, S.mems[a] exists.

    Let mem be the memory instance S.mems[a].

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const i from the stack.

    Let ea be the integer i+memarg.offset.

    If N is not part of the instruction, then:

        Let N be the bit width ∣t∣ of value type t.

    If ea+N/8 is larger than the length of mem.data, then:

        Trap.

    Let b∗ be the byte sequence mem.data[ea:N/8].

    If N and sx are part of the instruction, then:

        Let n be the integer for which bytesiN​(n)=b∗.

        Let c be the result of computing extend_sxN,∣t∣​(n).

    Else:

        Let c be the constant for which bytest​(c)=b∗.

    Push the value t.const c to the stack.

 S;F;(i32.const i) (t.load memarg)​↪​S;F;(t.const c)​(if∧∧​ea=i+memarg.offsetea+∣t∣/8≤∣S.mems[F.module.memaddrs[0]].data∣bytest​(c)=S.mems[F.module.memaddrs[0]].data[ea:∣t∣/8])​S;F;(i32.const i) (t.loadN_sx memarg)​↪​S;F;(t.const extend_sxN,∣t∣​(n))​(if∧∧​ea=i+memarg.offsetea+N/8≤∣S.mems[F.module.memaddrs[0]].data∣bytesiN​(n)=S.mems[F.module.memaddrs[0]].data[ea:N/8])​S;F;(i32.const k) (t.load(N_sx)? memarg)​↪​S;F;trap​(otherwise)​​
4.4.4.2. t.store memarg and t.storeN memarg

    Let F be the current frame.

    Assert: due to validation, F.module.memaddrs[0] exists.

    Let a be the memory address F.module.memaddrs[0].

    Assert: due to validation, S.mems[a] exists.

    Let mem be the memory instance S.mems[a].

    Assert: due to validation, a value of value type t is on the top of the stack.

    Pop the value t.const c from the stack.

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const i from the stack.

    Let ea be the integer i+memarg.offset.

    If N is not part of the instruction, then:

        Let N be the bit width ∣t∣ of value type t.

    If ea+N/8 is larger than the length of mem.data, then:

        Trap.

    If N is part of the instruction, then:

        Let n be the result of computing wrap∣t∣,N​(c).

        Let b∗ be the byte sequence bytesiN​(n).

    Else:

        Let b∗ be the byte sequence bytest​(c).

    Replace the bytes mem.data[ea:N/8] with b∗.

 S;F;(i32.const i) (t.const c) (t.store memarg)​↪​S′;F;ϵ​(if∧∧​ea=i+memarg.offsetea+∣t∣/8≤∣S.mems[F.module.memaddrs[0]].data∣S′=Swithmems[F.module.memaddrs[0]].data[ea:∣t∣/8]=bytest​(c)​S;F;(i32.const i) (t.const c) (t.storeN memarg)​↪​S′;F;ϵ​(if∧∧​ea=i+memarg.offsetea+N/8≤∣S.mems[F.module.memaddrs[0]].data∣S′=Swithmems[F.module.memaddrs[0]].data[ea:N/8]=bytesiN​(wrap∣t∣,N​(c))​S;F;(i32.const k) (t.const c) (t.storeN? memarg)​↪​S;F;trap​(otherwise)​​
4.4.4.3. memory.size

    Let F be the current frame.

    Assert: due to validation, F.module.memaddrs[0] exists.

    Let a be the memory address F.module.memaddrs[0].

    Assert: due to validation, S.mems[a] exists.

    Let mem be the memory instance S.mems[a].

    Let sz be the length of mem.data divided by the page size.

    Push the value i32.const sz to the stack.

S;F;memory.size​↪​S;F;(i32.const sz)​(if∣S.mems[F.module.memaddrs[0]].data∣=sz⋅64Ki)​​
4.4.4.4. memory.grow

    Let F be the current frame.

    Assert: due to validation, F.module.memaddrs[0] exists.

    Let a be the memory address F.module.memaddrs[0].

    Assert: due to validation, S.mems[a] exists.

    Let mem be the memory instance S.mems[a].

    Let sz be the length of S.mems[a] divided by the page size.

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const n from the stack.

    Let err be the i32 value 232−1, for which signed32​(err) is −1.

    Either, try growing mem by n pages:

        If it succeeds, push the value i32.const sz to the stack.

        Else, push the value i32.const err to the stack.

    Or, push the value i32.const err to the stack.

 S;F;(i32.const n) memory.grow​↪​S′;F;(i32.const sz)​(if∧∧​F.module.memaddrs[0]=asz=∣S.mems[a].data∣/64KiS′=Swithmems[a]=growmem(S.mems[a],n))​S;F;(i32.const n) memory.grow​↪​S;F;(i32.const signed32−1​(−1))​​​

Note

The memory.grow instruction is non-deterministic. It may either succeed, returning the old memory size sz, or fail, returning −1. Failure must occur if the referenced memory instance has a maximum size defined that would be exceeded. However, failure can occur in other cases as well. In practice, the choice depends on the resources available to the embedder.
4.4.5. Control Instructions
4.4.5.1. nop

    Do nothing.

nop​↪​ϵ​
4.4.5.2. unreachable

    Trap.

unreachable​↪​trap​
4.4.5.3. block blocktype instr∗ end

    Assert: due to validation, expandF​(blocktype) is defined.

    Let [t1m​]→[t2n​] be the function type expandF​(blocktype).

    Let L be the label whose arity is n and whose continuation is the end of the block.

    Assert: due to validation, there are at least m values on the top of the stack.

    Pop the values valm from the stack.

    Enter the block valm instr∗ with label L.

 F;valm block bt instr∗ end​↪​F;labeln​{ϵ} valm instr∗ end​(ifexpandF​(bt)=[t1m​]→[t2n​])​​
4.4.5.4. loop blocktype instr∗ end

    Assert: due to validation, expandF​(blocktype) is defined.

    Let [t1m​]→[t2n​] be the function type expandF​(blocktype).

    Let L be the label whose arity is m and whose continuation is the start of the loop.

    Assert: due to validation, there are at least m values on the top of the stack.

    Pop the values valm from the stack.

    Enter the block valm instr∗ with label L.

 F;valm loop bt instr∗ end​↪​F;labelm​{loop bt instr∗ end} valm instr∗ end​(ifexpandF​(bt)=[t1m​]→[t2n​])​​
4.4.5.5. if blocktype instr1∗​ else instr2∗​ end

    Assert: due to validation, expandF​(blocktype) is defined.

    Let [t1m​]→[t2n​] be the function type expandF​(blocktype).

    Let L be the label whose arity is n and whose continuation is the end of the if instruction.

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const c from the stack.

    Assert: due to validation, there are at least m values on the top of the stack.

    Pop the values valm from the stack.

    If c is non-zero, then:

        Enter the block valm instr1∗​ with label L.

    Else:

        Enter the block valm instr2∗​ with label L.

 F;valm (i32.const c) if bt instr1∗​ else instr2∗​ endF;valm (i32.const c) if bt instr1∗​ else instr2∗​ end​↪↪​F;labeln​{ϵ} valm instr1∗​ endF;labeln​{ϵ} valm instr2∗​ end​(ifc​=0∧expandF​(bt)=[t1m​]→[t2n​])(ifc=0∧expandF​(bt)=[t1m​]→[t2n​])​​
4.4.5.6. br l

    Assert: due to validation, the stack contains at least l+1 labels.

    Let L be the l-th label appearing on the stack, starting from the top and counting from zero.

    Let n be the arity of L.

    Assert: due to validation, there are at least n values on the top of the stack.

    Pop the values valn from the stack.

    Repeat l+1 times:

        While the top of the stack is a value, do:

            Pop the value from the stack.

        Assert: due to validation, the top of the stack now is a label.

        Pop the label from the stack.

    Push the values valn to the stack.

    Jump to the continuation of L.

 labeln​{instr∗} Bl[valn (br l)] end​↪​valn instr∗​​
4.4.5.7. br_if l

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const c from the stack.

    If c is non-zero, then:

        Execute the instruction (br l).

    Else:

        Do nothing.

 (i32.const c) (br_if l)(i32.const c) (br_if l)​↪↪​(br l)ϵ​(ifc​=0)(ifc=0)​​
4.4.5.8. br_table l∗ lN​

    Assert: due to validation, a value of value type i32 is on the top of the stack.

    Pop the value i32.const i from the stack.

    If i is smaller than the length of l∗, then:

        Let li​ be the label l∗[i].

        Execute the instruction (br li​).

    Else:

        Execute the instruction (br lN​).

 (i32.const i) (br_table l∗ lN​)(i32.const i) (br_table l∗ lN​)​↪↪​(br li​)(br lN​)​(ifl∗[i]=li​)(if∣l∗∣≤i)​​
4.4.5.9. return

    Let F be the current frame.

    Let n be the arity of F.

    Assert: due to validation, there are at least n values on the top of the stack.

    Pop the results valn from the stack.

    Assert: due to validation, the stack contains at least one frame.

    While the top of the stack is not a frame, do:

        Pop the top element from the stack.

    Assert: the top of the stack is the frame F.

    Pop the frame from the stack.

    Push valn to the stack.

    Jump to the instruction after the original call that pushed the frame.

 framen​{F} Bk[valn return] end​↪​valn​​
4.4.5.10. call x

    Let F be the current frame.

    Assert: due to validation, F.module.funcaddrs[x] exists.

    Let a be the function address F.module.funcaddrs[x].

    Invoke the function instance at address a.

F;(call x)​↪​F;(invoke a)​(ifF.module.funcaddrs[x]=a)​
4.4.5.11. call_indirect x

    Let F be the current frame.

    Assert: due to validation, F.module.tableaddrs[0] exists.

    Let ta be the table address F.module.tableaddrs[0].

    Assert: due to validation, S.tables[ta] exists.

    Let tab be the table instance S.tables[ta].

    Assert: due to validation, F.module.types[x] exists.

    Let ftexpect​ be the function type F.module.types[x].

    Assert: due to validation, a value with value type i32 is on the top of the stack.

    Pop the value i32.const i from the stack.

    If i is not smaller than the length of tab.elem, then:

        Trap.

    If tab.elem[i] is uninitialized, then:

        Trap.

    Let a be the function address tab.elem[i].

    Assert: due to validation, S.funcs[a] exists.

    Let f be the function instance S.funcs[a].

    Let ftactual​ be the function type f.type.

    If ftactual​ and ftexpect​ differ, then:

        Trap.

    Invoke the function instance at address a.

 S;F;(i32.const i) (call_indirect x)​↪​S;F;(invoke a)​(if∧∧​S.tables[F.module.tableaddrs[0]].elem[i]=aS.funcs[a]=fF.module.types[x]=f.type)​S;F;(i32.const i) (call_indirect x)​↪​S;F;trap​(otherwise)​​
4.4.6. Blocks

The following auxiliary rules define the semantics of executing an instruction sequence that forms a block.
4.4.6.1. Entering instr∗ with label L

    Push L to the stack.

    Jump to the start of the instruction sequence instr∗.

Note

No formal reduction rule is needed for entering an instruction sequence, because the label L is embedded in the administrative instruction that structured control instructions reduce to directly.
4.4.6.2. Exiting instr∗ with label L

When the end of a block is reached without a jump or trap aborting it, then the following steps are performed.

    Let m be the number of values on the top of the stack.

    Pop the values valm from the stack.

    Assert: due to validation, the label L is now on the top of the stack.

    Pop the label from the stack.

    Push valm back to the stack.

    Jump to the position after the end of the structured control instruction associated with the label L.

 labeln​{instr∗} valm end​↪​valm​​

Note

This semantics also applies to the instruction sequence contained in a loop instruction. Therefore, execution of a loop falls off the end, unless a backwards branch is performed explicitly.
4.4.7. Function Calls

The following auxiliary rules define the semantics of invoking a function instance through one of the call instructions and returning from it.
4.4.7.1. Invocation of function address a

    Assert: due to validation, S.funcs[a] exists.

    Let f be the function instance, S.funcs[a].

    Let [t1n​]→[t2m​] be the function type f.type.

    Let t∗ be the list of value types f.code.locals.

    Let instr∗ end be the expression f.code.body.

    Assert: due to validation, n values are on the top of the stack.

    Pop the values valn from the stack.

    Let val0∗​ be the list of zero values of types t∗.

    Let F be the frame {module f.module,locals valn val0∗​}.

    Push the activation of F with arity m to the stack.

    Let L be the label whose arity is m and whose continuation is the end of the function.

    Enter the instruction sequence instr∗ with label L.

 S;valn (invoke a)​↪​S;framem​{F} labelm​{} instr∗ end end​(if∧∧∧​S.funcs[a]=ff.type=[t1n​]→[t2m​]f.code={type x,locals tk,body instr∗ end}F={module f.module, locals valn (t.const 0)k})​​​
4.4.7.2. Returning from a function

When the end of a function is reached without a jump (i.e., return) or trap aborting it, then the following steps are performed.

    Let F be the current frame.

    Let n be the arity of the activation of F.

    Assert: due to validation, there are n values on the top of the stack.

    Pop the results valn from the stack.

    Assert: due to validation, the frame F is now on the top of the stack.

    Pop the frame from the stack.

    Push valn back to the stack.

    Jump to the instruction after the original call.

 framen​{F} valn end​↪​valn​​
4.4.7.3. Host Functions

Invoking a host function has non-deterministic behavior. It may either terminate with a trap or return regularly. However, in the latter case, it must consume and produce the right number and types of WebAssembly values on the stack, according to its function type.

A host function may also modify the store. However, all store modifications must result in an extension of the original store, i.e., they must only modify mutable contents and must not have instances removed. Furthermore, the resulting store must be valid, i.e., all data and code in it is well-typed.
 S;valn (invoke a)​↪​S′;result​(if∧​S.funcs[a]={type [t1n​]→[t2m​],hostcode hf}(S′;result)∈hf(S;valn))​S;valn (invoke a)​↪​S;valn (invoke a)​(if∧​S.funcs[a]={type [t1n​]→[t2m​],hostcode hf}⊥∈hf(S;valn))​​​

Here, hf(S;valn) denotes the implementation-defined execution of host function hf in current store S with arguments valn. It yields a set of possible outcomes, where each element is either a pair of a modified store S′ and a result or the special value ⊥ indicating divergence. A host function is non-deterministic if there is at least one argument for which the set of outcomes is not singular.

For a WebAssembly implementation to be sound in the presence of host functions, every host function instance must be valid, which means that it adheres to suitable pre- and post-conditions: under a valid store S, and given arguments valn matching the ascribed parameter types t1n​, executing the host function must yield a non-empty set of possible outcomes each of which is either divergence or consists of a valid store S′ that is an extension of S and a result matching the ascribed return types t2m​. All these notions are made precise in the Appendix.

Note

A host function can call back into WebAssembly by invoking a function exported from a module. However, the effects of any such call are subsumed by the non-deterministic behavior allowed for the host function.
4.4.8. Expressions

An expression is evaluated relative to a current frame pointing to its containing module instance.

    Jump to the start of the instruction sequence instr∗ of the expression.

    Execute the instruction sequence.

    Assert: due to validation, the top of the stack contains a value.

    Pop the value val from the stack.

The value val is the result of the evaluation.
S;F;instr∗↪S′;F′;instr′∗(ifS;F;instr∗ end↪S′;F′;instr′∗ end)

Note

Evaluation iterates this reduction rule until reaching a value. Expressions constituting function bodies are executed during function invocation.
4.5. Modules

For modules, the execution semantics primarily defines instantiation, which allocates instances for a module and its contained definitions, initializes tables and memories from contained element and data segments, and invokes the start function if present. It also includes invocation of exported functions.

Instantiation depends on a number of auxiliary notions for type-checking imports and allocating instances.
4.5.1. External Typing

For the purpose of checking external values against imports, such values are classified by external types. The following auxiliary typing rules specify this typing relation relative to a store S in which the referenced instances live.
4.5.1.1. func a

    The store entry S.funcs[a] must be a function instance {type functype,…}.

    Then func a is valid with external type func functype.

S⊢func a:func functypeS.funcs[a]={type functype,…}​
4.5.1.2. table a

    The store entry S.tables[a] must be a table instance {elem (fa?)n,max m?}.

    Then table a is valid with external type table ({min n,max m?} funcref).

S⊢table a:table ({min n,max m?} funcref)S.tables[a]={elem (fa?)n,max m?}​
4.5.1.3. mem a

    The store entry S.mems[a] must be a memory instance {data bn⋅64Ki,max m?}, for some n.

    Then mem a is valid with external type mem ({min n,max m?}).

S⊢mem a:mem {min n,max m?}S.mems[a]={data bn⋅64Ki,max m?}​
4.5.1.4. global a

    The store entry S.globals[a] must be a global instance {value (t.const c),mut mut}.

    Then global a is valid with external type global (mut t).

S⊢global a:global (mut t)S.globals[a]={value (t.const c),mut mut}​
4.5.2. Import Matching

When instantiating a module, external values must be provided whose types are matched against the respective external types classifying each import. In some cases, this allows for a simple form of subtyping, as defined below.
4.5.2.1. Limits

Limits {min n1​,max m1?​} match limits {min n2​,max m2?​} if and only if:

    n1​ is larger than or equal to n2​.

    Either:

        m2?​ is empty.

    Or:

        Both m1?​ and m2?​ are non-empty.

        m1​ is smaller than or equal to m2​.

 ⊢{min n1​,max m1?​}≤{min n2​,max ϵ}n1​≥n2​​⊢{min n1​,max m1​}≤{min n2​,max m2​}n1​≥n2​m1​≤m2​​​
4.5.2.2. Functions

An external type func functype1​ matches func functype2​ if and only if:

    Both functype1​ and functype2​ are the same.

 ⊢func functype≤func functype​​
4.5.2.3. Tables

An external type table (limits1​ elemtype1​) matches table (limits2​ elemtype2​) if and only if:

    Limits limits1​ match limits2​.

    Both elemtype1​ and elemtype2​ are the same.

⊢table (limits1​ elemtype)≤table (limits2​ elemtype)⊢limits1​≤limits2​​
4.5.2.4. Memories

An external type mem limits1​ matches mem limits2​ if and only if:

    Limits limits1​ match limits2​.

⊢mem limits1​≤mem limits2​⊢limits1​≤limits2​​
4.5.2.5. Globals

An external type global globaltype1​ matches global globaltype2​ if and only if:

    Both globaltype1​ and globaltype2​ are the same.

 ⊢global globaltype≤global globaltype​​
4.5.3. Allocation

New instances of functions, tables, memories, and globals are allocated in a store S, as defined by the following auxiliary functions.
4.5.3.1. Functions

    Let func be the function to allocate and moduleinst its module instance.

    Let a be the first free function address in S.

    Let functype be the function type moduleinst.types[func.type].

    Let funcinst be the function instance {type functype,module moduleinst,code func}.

    Append funcinst to the funcs of S.

    Return a.

 allocfunc(S,func,moduleinst)where:funcaddrfunctypefuncinstS′​=====​S′,funcaddr∣S.funcs∣moduleinst.types[func.type]{type functype,module moduleinst,code func}S⊕{funcs funcinst}​​
4.5.3.2. Host Functions

    Let hostfunc be the host function to allocate and functype its function type.

    Let a be the first free function address in S.

    Let funcinst be the function instance {type functype,hostcode hostfunc}.

    Append funcinst to the funcs of S.

    Return a.

 allochostfunc(S,functype,hostfunc)where:funcaddrfuncinstS′​====​S′,funcaddr∣S.funcs∣{type functype,hostcode hostfunc}S⊕{funcs funcinst}​​

Note

Host functions are never allocated by the WebAssembly semantics itself, but may be allocated by the embedder.
4.5.3.3. Tables

    Let tabletype be the table type to allocate.

    Let ({min n,max m?} elemtype) be the structure of table type tabletype.

    Let a be the first free table address in S.

    Let tableinst be the table instance {elem (ϵ)n,max m?} with n empty elements.

    Append tableinst to the tables of S.

    Return a.

alloctable(S,tabletype)where:tabletypetableaddrtableinstS′​=====​S′,tableaddr{min n,max m?} elemtype∣S.tables∣{elem (ϵ)n,max m?}S⊕{tables tableinst}​​
4.5.3.4. Memories

    Let memtype be the memory type to allocate.

    Let {min n,max m?} be the structure of memory type memtype.

    Let a be the first free memory address in S.

    Let meminst be the memory instance {data (0x00)n⋅64Ki,max m?} that contains n pages of zeroed bytes.

    Append meminst to the mems of S.

    Return a.

allocmem(S,memtype)where:memtypememaddrmeminstS′​=====​S′,memaddr{min n,max m?}∣S.mems∣{data (0x00)n⋅64Ki,max m?}S⊕{mems meminst}​​
4.5.3.5. Globals

    Let globaltype be the global type to allocate and val the value to initialize the global with.

    Let mut t be the structure of global type globaltype.

    Let a be the first free global address in S.

    Let globalinst be the global instance {value val,mut mut}.

    Append globalinst to the globals of S.

    Return a.

allocglobal(S,globaltype,val)where:globaltypeglobaladdrglobalinstS′​=====​S′,globaladdrmut t∣S.globals∣{value val,mut mut}S⊕{globals globalinst}​​
4.5.3.6. Growing tables

    Let tableinst be the table instance to grow and n the number of elements by which to grow it.

    Let len be n added to the length of tableinst.elem.

    If len is larger than or equal to 232, then fail.

    If tableinst.max is not empty and its value is smaller than len, then fail.

    Append n empty elements to tableinst.elem.

growtable(tableinst,n)​=​tableinstwithelem=tableinst.elem (ϵ)n(if∧∧​len=n+∣tableinst.elem∣len<232(tableinst.max=ϵ∨len≤tableinst.max))​​​
4.5.3.7. Growing memories

    Let meminst be the memory instance to grow and n the number of pages by which to grow it.

    Assert: The length of meminst.data is divisible by the page size 64Ki.

    Let len be n added to the length of meminst.data divided by the page size 64Ki.

    If len is larger than 216, then fail.

    If meminst.max is not empty and its value is smaller than len, then fail.

    Append n times 64Ki bytes with value 0x00 to meminst.data.

growmem(meminst,n)​=​meminstwithdata=meminst.data (0x00)n⋅64Ki(if∧∧​len=n+∣meminst.data∣/64Kilen≤216(meminst.max=ϵ∨len≤meminst.max))​​​
4.5.3.8. Modules

The allocation function for modules requires a suitable list of external values that are assumed to match the import vector of the module, and a list of initialization values for the module’s globals.

1. Let module be the module to allocate and externvalim∗​ the vector of external values providing the module’s imports, and val∗ the initialization values of the module’s globals.

    For each function funci​ in module.funcs, do:

        Let funcaddri​ be the function address resulting from allocating funci​ for the module instance moduleinst defined below.

    For each table tablei​ in module.tables, do:

        Let tableaddri​ be the table address resulting from allocating tablei​.type.

    For each memory memi​ in module.mems, do:

        Let memaddri​ be the memory address resulting from allocating memi​.type.

    For each global globali​ in module.globals, do:

        Let globaladdri​ be the global address resulting from allocating globali​.type with initializer value val∗[i].

    Let funcaddr∗ be the the concatenation of the function addresses funcaddri​ in index order.

    Let tableaddr∗ be the the concatenation of the table addresses tableaddri​ in index order.

    Let memaddr∗ be the the concatenation of the memory addresses memaddri​ in index order.

    Let globaladdr∗ be the the concatenation of the global addresses globaladdri​ in index order.

    Let funcaddrmod∗​ be the list of function addresses extracted from externvalim∗​, concatenated with funcaddr∗.

    Let tableaddrmod∗​ be the list of table addresses extracted from externvalim∗​, concatenated with tableaddr∗.

    Let memaddrmod∗​ be the list of memory addresses extracted from externvalim∗​, concatenated with memaddr∗.

    Let globaladdrmod∗​ be the list of global addresses extracted from externvalim∗​, concatenated with globaladdr∗.

    For each export exporti​ in module.exports, do:

        If exporti​ is a function export for function index x, then let externvali​ be the external value func (funcaddrmod∗​[x]).

        Else, if exporti​ is a table export for table index x, then let externvali​ be the external value table (tableaddrmod∗​[x]).

        Else, if exporti​ is a memory export for memory index x, then let externvali​ be the external value mem (memaddrmod∗​[x]).

        Else, if exporti​ is a global export for global index x, then let externvali​ be the external value global (globaladdrmod∗​[x]).

        Let exportinsti​ be the export instance {name (exporti​.name),value externvali​}.

    Let exportinst∗ be the the concatenation of the export instances exportinsti​ in index order.

    Let moduleinst be the module instance {types (module.types), funcaddrs funcaddrmod∗​, tableaddrs tableaddrmod∗​, memaddrs memaddrmod∗​, globaladdrs globaladdrmod∗​, exports exportinst∗}.

    Return moduleinst.

 allocmodule(S,module,externvalim∗​,val∗)​=​S′,moduleinst​​

where:
moduleinstS1​,funcaddr∗S2​,tableaddr∗S3​,memaddr∗S′,globaladdr∗exportinst∗funcs(externvalex∗​)tables(externvalex∗​)mems(externvalex∗​)globals(externvalex∗​)​==========​{ types module.types,funcaddrs funcs(externvalim∗​) funcaddr∗,tableaddrs tables(externvalim∗​) tableaddr∗,memaddrs mems(externvalim∗​) memaddr∗,globaladdrs globals(externvalim∗​) globaladdr∗,exports exportinst∗ }​allocfunc∗(S,module.funcs,moduleinst)alloctable∗(S1​,(table.type)∗) (wheretable∗=module.tables)allocmem∗(S2​,(mem.type)∗) (wheremem∗=module.mems)allocglobal∗(S3​,(global.type)∗,val∗) (whereglobal∗=module.globals){name (export.name),value externvalex​}∗(whereexport∗=module.exports)(moduleinst.funcaddrs[x])∗ (wherex∗=funcs(module.exports))(moduleinst.tableaddrs[x])∗(wherex∗=tables(module.exports))(moduleinst.memaddrs[x])∗(wherex∗=mems(module.exports))(moduleinst.globaladdrs[x])∗(wherex∗=globals(module.exports))​​

Here, the notation allocx∗ is shorthand for multiple allocations of object kind X, defined as follows:
allocx∗(S0​,Xn,…)where for all i < n:Si+1​,an[i]​==​Sn​,anallocx(Si​,Xn[i],…)​​

Moreover, if the dots … are a sequence An (as for globals), then the elements of this sequence are passed to the allocation function pointwise.

Note

The definition of module allocation is mutually recursive with the allocation of its associated functions, because the resulting module instance moduleinst is passed to the function allocator as an argument, in order to form the necessary closures. In an implementation, this recursion is easily unraveled by mutating one or the other in a secondary step.
4.5.4. Instantiation

Given a store S, a module module is instantiated with a list of external values externvaln supplying the required imports as follows.

Instantiation checks that the module is valid and the provided imports match the declared types, and may fail with an error otherwise. Instantiation can also result in a trap from executing the start function. It is up to the embedder to define how such conditions are reported.

    If module is not valid, then:

        Fail.

    Assert: module is valid with external types externtypeimm​ classifying its imports.

    If the number m of imports is not equal to the number n of provided external values, then:

        Fail.

    For each external value externvali​ in externvaln and external type externtypei′​ in externtypeimn​, do:

        If externvali​ is not valid with an external type externtypei​ in store S, then:

            Fail.

        If externtypei​ does not match externtypei′​, then:

            Fail.

    Let val∗ be the vector of global initialization values determined by module and externvaln. These may be calculated as follows.

        Let moduleinstim​ be the auxiliary module instance {globaladdrs globals(externvaln)} that only consists of the imported globals.

        Let Fim​ be the auxiliary frame {module moduleinstim​,locals ϵ}.

        Push the frame Fim​ to the stack.

        For each global globali​ in module.globals, do:

            Let vali​ be the result of evaluating the initializer expression globali​.init.

        Assert: due to validation, the frame Fim​ is now on the top of the stack.

        Pop the frame Fim​ from the stack.

    Let moduleinst be a new module instance allocated from module in store S with imports externvaln and global initializer values val∗, and let S′ be the extended store produced by module allocation.

    Let F be the frame {module moduleinst,locals ϵ}.

    Push the frame F to the stack.

    For each element segment elemi​ in module.elem, do:

            Let eovali​ be the result of evaluating the expression elemi​.offset.

            Assert: due to validation, eovali​ is of the form i32.const eoi​.

            Let tableidxi​ be the table index elemi​.table.

            Assert: due to validation, moduleinst.tableaddrs[tableidxi​] exists.

            Let tableaddri​ be the table address moduleinst.tableaddrs[tableidxi​].

            Assert: due to validation, S′.tables[tableaddri​] exists.

            Let tableinsti​ be the table instance S′.tables[tableaddri​].

            Let eendi​ be eoi​ plus the length of elemi​.init.

            If eendi​ is larger than the length of tableinsti​.elem, then:

                Fail.

    For each data segment datai​ in module.data, do:

        Let dovali​ be the result of evaluating the expression datai​.offset.

        Assert: due to validation, dovali​ is of the form i32.const doi​.

        Let memidxi​ be the memory index datai​.data.

        Assert: due to validation, moduleinst.memaddrs[memidxi​] exists.

        Let memaddri​ be the memory address moduleinst.memaddrs[memidxi​].

        Assert: due to validation, S′.mems[memaddri​] exists.

        Let meminsti​ be the memory instance S′.mems[memaddri​].

        Let dendi​ be doi​ plus the length of datai​.init.

        If dendi​ is larger than the length of meminsti​.data, then:

            Fail.

    Assert: due to validation, the frame F is now on the top of the stack.

    Pop the frame from the stack.

    For each element segment elemi​ in module.elem, do:

        For each function index funcidxij​ in elemi​.init (starting with j=0), do:

            Assert: due to validation, moduleinst.funcaddrs[funcidxij​] exists.

            Let funcaddrij​ be the function address moduleinst.funcaddrs[funcidxij​].

            Replace tableinsti​.elem[eoi​+j] with funcaddrij​.

    For each data segment datai​ in module.data, do:

        For each byte bij​ in datai​.init (starting with j=0), do:

            Replace meminsti​.data[doi​+j] with bij​.

    If the start function module.start is not empty, then:

        Assert: due to validation, moduleinst.funcaddrs[module.start.func] exists.

        Let funcaddr be the function address moduleinst.funcaddrs[module.start.func].

        Invoke the function instance at funcaddr.

 instantiate(S,module,externvaln)S;F;init_elem a i ϵS;F;init_elem a i (x0​ x∗)S;F;init_data a i ϵS;F;init_data a i (b0​ b∗)​=(if∧∧∧∧∧∧∧∧∧∧∧∧∧∧∧∧↪↪↪↪​S′;F;(init_elem tableaddr eo elem.init)∗(init_data memaddr do data.init)∗(invoke funcaddr)?​⊢module:externtypeimn​→externtypeex∗​(S⊢externval:externtype)n(⊢externtype≤externtypeim​)nmodule.globals=global∗module.elem=elem∗module.data=data∗module.start=start?S′,moduleinst=allocmodule(S,module,externvaln,val∗)F={module moduleinst,locals ϵ}(S′;F;global.init↪∗S′;F;val end)∗(S′;F;elem.offset↪∗S′;F;i32.const eo end)∗(S′;F;data.offset↪∗S′;F;i32.const do end)∗(eo+∣elem.init∣≤∣S′.tables[tableaddr].elem∣)∗(do+∣data.init∣≤∣S′.mems[memaddr].data∣)∗(tableaddr=moduleinst.tableaddrs[elem.table])∗(memaddr=moduleinst.memaddrs[data.data])∗(funcaddr=moduleinst.funcaddrs[start.func])?)S;F;ϵS′;F;init_elem a (i+1) x∗(ifS′=Swithtables[a].elem[i]=F.module.funcaddrs[x0​])S;F;ϵS′;F;init_data a (i+1) b∗(ifS′=Swithmems[a].data[i]=b0​)​​

Note

Module allocation and the evaluation of global initializers are mutually recursive because the global initialization values val∗ are passed to the module allocator but depend on the store S′ and module instance moduleinst returned by allocation. However, this recursion is just a specification device. Due to validation, the initialization values can easily be determined from a simple pre-pass that evaluates global initializers in the initial store.

All failure conditions are checked before any observable mutation of the store takes place. Store mutation is not atomic; it happens in individual steps that may be interleaved with other threads.

Evaluation of constant expressions does not affect the store.
4.5.5. Invocation

Once a module has been instantiated, any exported function can be invoked externally via its function address funcaddr in the store S and an appropriate list val∗ of argument values.

Invocation may fail with an error if the arguments do not fit the function type. Invocation can also result in a trap. It is up to the embedder to define how such conditions are reported.

Note

If the embedder API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps can occur.

The following steps are performed:

    Assert: S.funcs[funcaddr] exists.

    Let funcinst be the function instance S.funcs[funcaddr].

    Let [t1n​]→[t2m​] be the function type funcinst.type.

    If the length ∣val∗∣ of the provided argument values is different from the number n of expected arguments, then:

        Fail.

    For each value type ti​ in t1n​ and corresponding value vali​ in val∗, do:

        If vali​ is not ti​.const ci​ for some ci​, then:

            Fail.

    Let F be the dummy frame {module {},locals ϵ}.

    Push the frame F to the stack.

    Push the values val∗ to the stack.

    Invoke the function instance at address funcaddr.

Once the function has returned, the following steps are executed:

    Assert: due to validation, m values are on the top of the stack.

    Pop valresm​ from the stack.

The values valresm​ are returned as the results of the invocation.
 invoke(S,funcaddr,valn)​=(if∧∧​S;F;valn (invoke funcaddr)S.funcs[funcaddr].type=[t1n​]→[t2m​]valn=(t1​.const c)nF={module {},locals ϵ})​​
5. Binary Format
5.1. Conventions

The binary format for WebAssembly modules is a dense linear encoding of their abstract syntax. 1

The format is defined by an attribute grammar whose only terminal symbols are bytes. A byte sequence is a well-formed encoding of a module if and only if it is generated by the grammar.

Each production of this grammar has exactly one synthesized attribute: the abstract syntax that the respective byte sequence encodes. Thus, the attribute grammar implicitly defines a decoding function (i.e., a parsing function for the binary format).

Except for a few exceptions, the binary grammar closely mirrors the grammar of the abstract syntax.

Note

Some phrases of abstract syntax have multiple possible encodings in the binary format. For example, numbers may be encoded as if they had optional leading zeros. Implementations of decoders must support all possible alternatives; implementations of encoders can pick any allowed encoding.

The recommended extension for files containing WebAssembly modules in binary format is “.wasm” and the recommended Media Type is “application/wasm”.

1

    Additional encoding layers – for example, introducing compression – may be defined on top of the basic representation defined here. However, such layers are outside the scope of the current specification.

5.1.1. Grammar

The following conventions are adopted in defining grammar rules for the binary format. They mirror the conventions used for abstract syntax. In order to distinguish symbols of the binary syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

    Terminal symbols are bytes expressed in hexadecimal notation: 0x0F.

    Nonterminal symbols are written in typewriter font: valtype,instr.

    Bn is a sequence of n≥0 iterations of B.

    B∗ is a possibly empty sequence of iterations of B. (This is a shorthand for Bn used where n is not relevant.)

    B? is an optional occurrence of B. (This is a shorthand for Bn where n≤1.)

    x:B denotes the same language as the nonterminal B, but also binds the variable x to the attribute synthesized for B.

    Productions are written sym::=B1​⇒A1​ ∣ … ∣ Bn​⇒An​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Bi​.

    Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.

Note

For example, the binary grammar for value types is given as follows:
​valtype​::=∣∣∣​0x7F0x7E0x7D0x7C​⇒⇒⇒⇒​i32i64f32f64​​

Consequently, the byte 0x7F encodes the type i32, 0x7E encodes the type i64, and so forth. No other byte value is allowed as the encoding of a value type.

The binary grammar for limits is defined as follows:
​limits​::=∣​0x00  n:u320x01  n:u32  m:u32​⇒⇒​{min n,max ϵ}{min n,max m}​​

That is, a limits pair is encoded as either the byte 0x00 followed by the encoding of a u32 value, or the byte 0x01 followed by two such encodings. The variables n and m name the attributes of the respective u32 nonterminals, which in this case are the actual unsigned integers those decode into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.
5.1.2. Auxiliary Notation

When dealing with binary encodings the following notation is also used:

    ϵ denotes the empty byte sequence.

    ∣∣B∣∣ is the length of the byte sequence generated from the production B in a derivation.

5.1.3. Vectors

Vectors are encoded with their u32 length followed by the encoding of their element sequence.
​vec(B)​::=​n:u32  (x:B)n​⇒​xn​​
5.2. Values
5.2.1. Bytes

Bytes encode themselves.
​byte​::=∣∣​0x000xFF​⇒…⇒​0x000xFF​​
5.2.2. Integers

All integers are encoded using the LEB128 variable-length integer encoding, in either unsigned or signed variant.

Unsigned integers are encoded in unsigned LEB128 format. As an additional constraint, the total number of bytes encoding a value of type uN must not exceed ceil(N/7) bytes.
​uN​::=∣​n:byten:byte  m:u(N−7)​⇒⇒​n27⋅m+(n−27)​(ifn<27∧n<2N)(ifn≥27∧N>7)​​

Signed integers are encoded in signed LEB128 format, which uses a two’s complement representation. As an additional constraint, the total number of bytes encoding a value of type sN must not exceed ceil(N/7) bytes.
​sN​::=∣∣​n:byten:byten:byte  m:s(N−7)​⇒⇒⇒​nn−2727⋅m+(n−27)​(ifn<26∧n<2N−1)(if26≤n<27∧n≥27−2N−1)(ifn≥27∧N>7)​​

Uninterpreted integers are encoded as signed integers.
​iN​::=​n:sN​⇒​i​(ifn=signediN​(i))​

Note

The side conditions N>7 in the productions for non-terminal bytes of the u and s encodings restrict the encoding’s length. However, “trailing zeros” are still allowed within these bounds. For example, 0x03 and 0x83 0x00 are both well-formed encodings for the value 3 as a u8. Similarly, either of 0x7e and 0xFE 0x7F and 0xFE 0xFF 0x7F are well-formed encodings of the value −2 as a s16.

The side conditions on the value n of terminal bytes further enforce that any unused bits in these bytes must be 0 for positive values and 1 for negative ones. For example, 0x83 0x10 is malformed as a u8 encoding. Similarly, both 0x83 0x3E and 0xFF 0x7B are malformed as s8 encodings.
5.2.3. Floating-Point

Floating-point values are encoded directly by their [IEEE-754-2019] (Section 3.4) bit pattern in little endian byte order:
​fN​::=​b∗:byteN/8​⇒​bytesfN−1​(b∗)​​
5.2.4. Names

Names are encoded as a vector of bytes containing the [UNICODE] (Section 3.9) UTF-8 encoding of the name’s character sequence.
​name​::=​b∗:vec(byte)​⇒​name​​(ifutf8(name)=b∗)​​

The auxiliary utf8 function expressing this encoding is defined as follows:
utf8(c∗)utf8(c)utf8(c)utf8(c)utf8(c)​=====​(utf8(c))∗bb1​ b2​b1​ b2​ b3​b1​ b2​ b3​ b4​​(if∧​c<U+80c=b)​(if∧​U+80≤c<U+800c=26(b1​−0xC0)+(b2​−0x80))​(if∧​U+800≤c<U+D800∨U+E000≤c<U+10000c=212(b1​−0xE0)+26(b2​−0x80)+(b3​−0x80))​(if∧​U+10000≤c<U+110000c=218(b1​−0xF0)+212(b2​−0x80)+26(b3​−0x80)+(b4​−0x80))​​whereb2​,b3​,b4​<0xC0​​

Note

Unlike in some other formats, name strings are not 0-terminated.
5.3. Types
5.3.1. Value Types

Value types are encoded by a single byte.
​valtype​::=∣∣∣​0x7F0x7E0x7D0x7C​⇒⇒⇒⇒​i32i64f32f64​​

Note

Value types can occur in contexts where type indices are also allowed, such as in the case of block types. Thus, the binary format for types corresponds to the signed LEB128 encoding of small negative sN values, so that they can coexist with (positive) type indices in the future.
5.3.2. Result Types

Result types are encoded by the respective vectors of value types `.
​resulttype​::=​t∗:vec(valtype)​⇒​[t∗]​​
5.3.3. Function Types

Function types are encoded by the byte 0x60 followed by the respective vectors of parameter and result types.
​functype​::=​0x60  rt1​:resulttype  rt2​:resulttype​⇒​rt1​→rt2​​​
5.3.4. Limits

Limits are encoded with a preceding flag indicating whether a maximum is present.
​limits​::=∣​0x00  n:u320x01  n:u32  m:u32​⇒⇒​{min n,max ϵ}{min n,max m}​​
5.3.5. Memory Types

Memory types are encoded with their limits.
​memtype​::=​lim:limits​⇒​lim​​
5.3.6. Table Types

Table types are encoded with their limits and a constant byte indicating their element type.
​tabletypeelemtype​::=::=​et:elemtype  lim:limits0x70​⇒⇒​lim etfuncref​​
5.3.7. Global Types

Global types are encoded by their value type and a flag for their mutability.
​globaltypemut​::=::=∣​t:valtype  m:mut0x000x01​⇒⇒⇒​m tconstvar​​
5.4. Instructions

Instructions are encoded by opcodes. Each opcode is represented by a single byte, and is followed by the instruction’s immediate arguments, where present. The only exception are structured control instructions, which consist of several opcodes bracketing their nested instruction sequences.

Note

Gaps in the byte code ranges for encoding instructions are reserved for future extensions.
5.4.1. Control Instructions

Control instructions have varying encodings. For structured instructions, the instruction sequences forming nested blocks are terminated with explicit opcodes for end and else.

Block types are encoded in special compressed form, by either the byte 0x40 indicating the empty type, as a single value type, or as a type index encoded as a positive signed integer.
​blocktypeinstr​::=∣∣::=∣∣∣∣∣∣∣∣∣∣∣​0x40t:valtypex:s330x000x010x02  bt:blocktype  (in:instr)∗  0x0B0x03  bt:blocktype  (in:instr)∗  0x0B0x04  bt:blocktype  (in:instr)∗  0x0B0x04  bt:blocktype  (in1​:instr)∗  0x05  (in2​:instr)∗  0x0B0x0C  l:labelidx0x0D  l:labelidx0x0E  l∗:vec(labelidx)  lN​:labelidx0x0F0x10  x:funcidx0x11  x:typeidx  0x00​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​ϵtxunreachablenopblock bt in∗ endloop bt in∗ endif bt in∗ else ϵ endif bt in1∗​ else in2∗​ endbr lbr_if lbr_table l∗ lN​returncall xcall_indirect x​(ifx≥0)​

Note

The else opcode 0x05 in the encoding of an if instruction can be omitted if the following instruction sequence is empty.

Unlike any other occurrence, the type index in a block type is encoded as a positive signed integer, so that its signed LEB128 bit pattern cannot collide with the encoding of value types or the special code 0x40, which correspond to the LEB128 encoding of negative integers. To avoid any loss in the range of allowed indices, it is treated as a 33 bit signed integer.

In future versions of WebAssembly, the zero byte occurring in the encoding of the call_indirect instruction may be used to index additional tables.
5.4.2. Parametric Instructions

Parametric instructions are represented by single byte codes.
​instr​::=∣∣​…0x1A0x1B​⇒⇒​dropselect​​
5.4.3. Variable Instructions

Variable instructions are represented by byte codes followed by the encoding of the respective index.
​instr​::=∣∣∣∣∣​…0x20  x:localidx0x21  x:localidx0x22  x:localidx0x23  x:globalidx0x24  x:globalidx​⇒⇒⇒⇒⇒​local.get xlocal.set xlocal.tee xglobal.get xglobal.set x​​
5.4.4. Memory Instructions

Each variant of memory instruction is encoded with a different byte code. Loads and stores are followed by the encoding of their memarg immediate.
​memarginstr​::=::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​a:u32  o:u32…0x28  m:memarg0x29  m:memarg0x2A  m:memarg0x2B  m:memarg0x2C  m:memarg0x2D  m:memarg0x2E  m:memarg0x2F  m:memarg0x30  m:memarg0x31  m:memarg0x32  m:memarg0x33  m:memarg0x34  m:memarg0x35  m:memarg0x36  m:memarg0x37  m:memarg0x38  m:memarg0x39  m:memarg0x3A  m:memarg0x3B  m:memarg0x3C  m:memarg0x3D  m:memarg0x3E  m:memarg0x3F  0x000x40  0x00​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​{align a, offset o}i32.load mi64.load mf32.load mf64.load mi32.load8_s mi32.load8_u mi32.load16_s mi32.load16_u mi64.load8_s mi64.load8_u mi64.load16_s mi64.load16_u mi64.load32_s mi64.load32_u mi32.store mi64.store mf32.store mf64.store mi32.store8 mi32.store16 mi64.store8 mi64.store16 mi64.store32 mmemory.sizememory.grow​​

Note

In future versions of WebAssembly, the additional zero bytes occurring in the encoding of the memory.size and memory.grow instructions may be used to index additional memories.
5.4.5. Numeric Instructions

All variants of numeric instructions are represented by separate byte codes.

The const instructions are followed by the respective literal.
​instr​::=∣∣∣∣​…0x41  n:i320x42  n:i640x43  z:f320x44  z:f64​⇒⇒⇒⇒​i32.const ni64.const nf32.const zf64.const z​​

All other numeric instructions are plain opcodes without any immediates.
​instr​::=∣∣∣∣∣∣∣∣∣∣∣​…0x450x460x470x480x490x4A0x4B0x4C0x4D0x4E0x4F​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.eqzi32.eqi32.nei32.lt_si32.lt_ui32.gt_si32.gt_ui32.le_si32.le_ui32.ge_si32.ge_u​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣​…0x500x510x520x530x540x550x560x570x580x590x5A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi64.eqzi64.eqi64.nei64.lt_si64.lt_ui64.gt_si64.gt_ui64.le_si64.le_ui64.ge_si64.ge_u​​
​instr​::=∣∣∣∣∣∣​…0x5B0x5C0x5D0x5E0x5F0x60​⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf32.eqf32.nef32.ltf32.gtf32.lef32.ge​​
​instr​::=∣∣∣∣∣∣​…0x610x620x630x640x650x66​⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf64.eqf64.nef64.ltf64.gtf64.lef64.ge​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x670x680x690x6A0x6B0x6C0x6D0x6E0x6F0x700x710x720x730x740x750x760x770x78​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.clzi32.ctzi32.popcnti32.addi32.subi32.muli32.div_si32.div_ui32.rem_si32.rem_ui32.andi32.ori32.xori32.shli32.shr_si32.shr_ui32.rotli32.rotr​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x790x7A0x7B0x7C0x7D0x7E0x7F0x800x810x820x830x840x850x860x870x880x890x8A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi64.clzi64.ctzi64.popcnti64.addi64.subi64.muli64.div_si64.div_ui64.rem_si64.rem_ui64.andi64.ori64.xori64.shli64.shr_si64.shr_ui64.rotli64.rotr​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x8B0x8C0x8D0x8E0x8F0x900x910x920x930x940x950x960x970x98​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf32.absf32.negf32.ceilf32.floorf32.truncf32.nearestf32.sqrtf32.addf32.subf32.mulf32.divf32.minf32.maxf32.copysign​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x990x9A0x9B0x9C0x9D0x9E0x9F0xA00xA10xA20xA30xA40xA50xA6​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf64.absf64.negf64.ceilf64.floorf64.truncf64.nearestf64.sqrtf64.addf64.subf64.mulf64.divf64.minf64.maxf64.copysign​​
​instr​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xA70xA80xA90xAA0xAB0xAC0xAD0xAE0xAF0xB00xB10xB20xB30xB40xB50xB60xB70xB80xB90xBA0xBB0xBC0xBD0xBE0xBF​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.wrap_i64i32.trunc_f32_si32.trunc_f32_ui32.trunc_f64_si32.trunc_f64_ui64.extend_i32_si64.extend_i32_ui64.trunc_f32_si64.trunc_f32_ui64.trunc_f64_si64.trunc_f64_uf32.convert_i32_sf32.convert_i32_uf32.convert_i64_sf32.convert_i64_uf32.demote_f64f64.convert_i32_sf64.convert_i32_uf64.convert_i64_sf64.convert_i64_uf64.promote_f32i32.reinterpret_f32i64.reinterpret_f64f32.reinterpret_i32f64.reinterpret_i64​​

The saturating truncation instructions all have a one byte prefix.
​instr​::=∣∣∣∣∣∣∣∣​…0xFC 0x000xFC 0x010xFC 0x020xFC 0x030xFC 0x040xFC 0x050xFC 0x060xFC 0x07​⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.trunc_sat_f32_si32.trunc_sat_f32_ui32.trunc_sat_f64_si32.trunc_sat_f64_ui64.trunc_sat_f32_si64.trunc_sat_f32_ui64.trunc_sat_f64_si64.trunc_sat_f64_u​​
​instr​::=∣∣∣∣∣​…0xC00xC10xC20xC30xC4​⇒⇒⇒⇒⇒​thisshouldbeenoughi32.extend8_si32.extend16_si64.extend8_si64.extend16_si64.extend32_s​​
5.4.6. Expressions

Expressions are encoded by their instruction sequence terminated with an explicit 0x0B opcode for end.
​expr​::=​(in:instr)∗  0x0B​⇒​in∗ end​​
5.5. Modules

The binary encoding of modules is organized into sections. Most sections correspond to one component of a module record, except that function definitions are split into two sections, separating their type declarations in the function section from their bodies in the code section.

Note

This separation enables parallel and streaming compilation of the functions in a module.
5.5.1. Indices

All indices are encoded with their respective value.
​typeidxfuncidxtableidxmemidxglobalidxlocalidxlabelidx​::=::=::=::=::=::=::=​x:u32x:u32x:u32x:u32x:u32x:u32l:u32​⇒⇒⇒⇒⇒⇒⇒​xxxxxxl​​
5.5.2. Sections

Each section consists of

    a one-byte section id,

    the u32 size of the contents, in bytes,

    the actual contents, whose structure is depended on the section id.

Every section is optional; an omitted section is equivalent to the section being present with empty contents.

The following parameterized grammar rule defines the generic structure of a section with id N and contents described by the grammar B.
​sectionN​(B)​::=∣​N:byte  size:u32  cont:Bϵ​⇒⇒​contϵ​(ifsize=∣∣B∣∣)​

For most sections, the contents B encodes a vector. In these cases, the empty result ϵ is interpreted as the empty vector.

Note

Other than for unknown custom sections, the size is not required for decoding, but can be used to skip sections when navigating through a binary. The module is malformed if the size does not match the length of the binary contents B.

The following section ids are used:

Id
	

Section

0
	

custom section

1
	

type section

2
	

import section

3
	

function section

4
	

table section

5
	

memory section

6
	

global section

7
	

export section

8
	

start section

9
	

element section

10
	

code section

11
	

data section
5.5.3. Custom Section

Custom sections have the id 0. They are intended to be used for debugging information or third-party extensions, and are ignored by the WebAssembly semantics. Their contents consist of a name further identifying the custom section, followed by an uninterpreted sequence of bytes for custom use.
​customseccustom​::=::=​section0​(custom)name  byte∗​​

Note

If an implementation interprets the data of a custom section, then errors in that data, or the placement of the section, must not invalidate the module.
5.5.4. Type Section

The type section has the id 1. It decodes into a vector of function types that represent the types component of a module.
​typesec​::=​ft∗:section1​(vec(functype))​⇒​ft∗​​
5.5.5. Import Section

The import section has the id 2. It decodes into a vector of imports that represent the imports component of a module.
​importsecimportimportdesc​::=::=::=∣∣∣​im∗:section2​(vec(import))mod:name  nm:name  d:importdesc0x00  x:typeidx0x01  tt:tabletype0x02  mt:memtype0x03  gt:globaltype​⇒⇒⇒⇒⇒⇒​im∗{module mod,name nm,desc d}func xtable ttmem mtglobal gt​​
5.5.6. Function Section

The function section has the id 3. It decodes into a vector of type indices that represent the type fields of the functions in the funcs component of a module. The locals and body fields of the respective functions are encoded separately in the code section.
​funcsec​::=​x∗:section3​(vec(typeidx))​⇒​x∗​​
5.5.7. Table Section

The table section has the id 4. It decodes into a vector of tables that represent the tables component of a module.
​tablesectable​::=::=​tab∗:section4​(vec(table))tt:tabletype​⇒⇒​tab∗{type tt}​​
5.5.8. Memory Section

The memory section has the id 5. It decodes into a vector of memories that represent the mems component of a module.
​memsecmem​::=::=​mem∗:section5​(vec(mem))mt:memtype​⇒⇒​mem∗{type mt}​​
5.5.9. Global Section

The global section has the id 6. It decodes into a vector of globals that represent the globals component of a module.
​globalsecglobal​::=::=​glob∗:section6​(vec(global))gt:globaltype  e:expr​⇒⇒​glob∗{type gt,init e}​​
5.5.10. Export Section

The export section has the id 7. It decodes into a vector of exports that represent the exports component of a module.
​exportsecexportexportdesc​::=::=::=∣∣∣​ex∗:section7​(vec(export))nm:name  d:exportdesc0x00  x:funcidx0x01  x:tableidx0x02  x:memidx0x03  x:globalidx​⇒⇒⇒⇒⇒⇒​ex∗{name nm,desc d}func xtable xmem xglobal x​​
5.5.11. Start Section

The start section has the id 8. It decodes into an optional start function that represents the start component of a module.
​startsecstart​::=::=​st?:section8​(start)x:funcidx​⇒⇒​st?{func x}​​
5.5.12. Element Section

The element section has the id 9. It decodes into a vector of element segments that represent the elem component of a module.
​elemsecelem​::=::=​seg∗:section9​(vec(elem))x:tableidx  e:expr  y∗:vec(funcidx)​⇒⇒​seg{table x,offset e,init y∗}​​
5.5.13. Code Section

The code section has the id 10. It decodes into a vector of code entries that are pairs of value type vectors and expressions. They represent the locals and body field of the functions in the funcs component of a module. The type fields of the respective functions are encoded separately in the function section.

The encoding of each code entry consists of

    the u32 size of the function code in bytes,

    the actual function code, which in turn consists of

        the declaration of locals,

        the function body as an expression.

Local declarations are compressed into a vector whose entries consist of

    a u32 count,

    a value type,

denoting count locals of the same value type.
​codeseccodefunclocals​::=::=::=::=​code∗:section10​(vec(code))size:u32  code:func(t∗)∗:vec(locals)  e:exprn:u32  t:valtype​⇒⇒⇒⇒​code∗codeconcat((t∗)∗),e∗tn​(ifsize=∣∣func∣∣)(if∣concat((t∗)∗)∣<232)​​

Here, code ranges over pairs (valtype∗,expr). The meta function concat((t∗)∗) concatenates all sequences ti∗​ in (t∗)∗. Any code for which the length of the resulting sequence is out of bounds of the maximum size of a vector is malformed.

Note

Like with sections, the code size is not needed for decoding, but can be used to skip functions when navigating through a binary. The module is malformed if a size does not match the length of the respective function code.
5.5.14. Data Section

The data section has the id 11. It decodes into a vector of data segments that represent the data component of a module.
​datasecdata​::=::=​seg∗:section11​(vec(data))x:memidx  e:expr  b∗:vec(byte)​⇒⇒​seg{data x,offset e,init b∗}​​
5.5.15. Modules

The encoding of a module starts with a preamble containing a 4-byte magic number (the string ‘\0asm’) and a version field. The current version of the WebAssembly binary format is 1.

The preamble is followed by a sequence of sections. Custom sections may be inserted at any place in this sequence, while other sections must occur at most once and in the prescribed order. All sections can be empty.

The lengths of vectors produced by the (possibly empty) function and code section must match up.
​magicversionmodule​::=::=::=​0x00 0x61 0x73 0x6D0x01 0x00 0x00 0x00magicversioncustomsec∗functype∗:typeseccustomsec∗import∗:importseccustomsec∗typeidxn:funcseccustomsec∗table∗:tableseccustomsec∗mem∗:memseccustomsec∗global∗:globalseccustomsec∗export∗:exportseccustomsec∗start?:startseccustomsec∗elem∗:elemseccustomsec∗coden:codeseccustomsec∗data∗:dataseccustomsec∗⇒{ types functype∗,funcs funcn,tables table∗,mems mem∗,globals global∗,elem elem∗,data data∗,start start?,imports import∗,exports export∗ }​​​

where for each ti∗​,ei​ in coden,
funcn[i]={type typeidxn[i],locals ti∗​,body ei​})​

Note

The version of the WebAssembly binary format may increase in the future if backward-incompatible changes have to be made to the format. However, such changes are expected to occur very infrequently, if ever. The binary format is intended to be forward-compatible, such that future extensions can be made without incrementing its version.
6. Text Format
6.1. Conventions

The textual format for WebAssembly modules is a rendering of their abstract syntax into S-expressions.

Like the binary format, the text format is defined by an attribute grammar. A text string is a well-formed description of a module if and only if it is generated by the grammar. Each production of this grammar has at most one synthesized attribute: the abstract syntax that the respective character sequence expresses. Thus, the attribute grammar implicitly defines a parsing function. Some productions also take a context as an inherited attribute that records bound identifers.

Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax. However, it also defines a number of abbreviations that are “syntactic sugar” over the core syntax.

The recommended extension for files containing WebAssembly modules in text format is “.wat”. Files with this extension are assumed to be encoded in UTF-8, as per [UNICODE] (Section 2.5).
6.1.1. Grammar

The following conventions are adopted in defining grammar rules of the text format. They mirror the conventions used for abstract syntax and for the binary format. In order to distinguish symbols of the textual syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

    Terminal symbols are either literal strings of characters enclosed in quotes or expressed as [UNICODE] scalar values: ‘module’, U+0A. (All characters written literally are unambiguously drawn from the 7-bit ASCII subset of Unicode.)

    Nonterminal symbols are written in typewriter font: valtype,instr.

    Tn is a sequence of n≥0 iterations of T.

    T∗ is a possibly empty sequence of iterations of T. (This is a shorthand for Tn used where n is not relevant.)

    T+ is a sequence of one or more iterations of T. (This is a shorthand for Tn where n≥1.)

    T? is an optional occurrence of T. (This is a shorthand for Tn where n≤1.)

    x:T denotes the same language as the nonterminal T, but also binds the variable x to the attribute synthesized for T.

    Productions are written sym::=T1​⇒A1​ ∣ … ∣ Tn​⇒An​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Ti​.

    Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.

    A distinction is made between lexical and syntactic productions. For the latter, arbitrary white space is allowed in any place where the grammar contains spaces. The productions defining lexical syntax and the syntax of values are considered lexical, all others are syntactic.

Note

For example, the textual grammar for value types is given as follows:
​valtype​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​i32i64f32f64​​

The textual grammar for limits is defined as follows:
​limits​::=∣​n:u32n:u32  m:u32​⇒⇒​{min n,max ϵ}{min n,max m}​​

The variables n and m name the attributes of the respective u32 nonterminals, which in this case are the actual unsigned integers those parse into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.
6.1.2. Abbreviations

In addition to the core grammar, which corresponds directly to the abstract syntax, the textual syntax also defines a number of abbreviations that can be used for convenience and readability.

Abbreviations are defined by rewrite rules specifying their expansion into the core syntax:
abbreviation syntax≡expanded syntax

These expansions are assumed to be applied, recursively and in order of appearance, before applying the core grammar rules to construct the abstract syntax.
6.1.3. Contexts

The text format allows the use of symbolic identifiers in place of indices. To resolve these identifiers into concrete indices, some grammar production are indexed by an identifier context I as a synthesized attribute that records the declared identifiers in each index space. In addition, the context records the types defined in the module, so that parameter indices can be computed for functions.

It is convenient to define identifier contexts as records I with abstract syntax as follows:
​I​::=​{​typesfuncstablesmemsglobalslocalslabelstypedefs​(id?)∗,(id?)∗,(id?)∗,(id?)∗,(id?)∗,(id?)∗,(id?)∗,functype∗ }​​​

For each index space, such a context contains the list of identifiers assigned to the defined indices. Unnamed indices are associated with empty (ϵ) entries in these lists.

An identifier context is well-formed if no index space contains duplicate identifiers.
6.1.3.1. Conventions

To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts. For example, the record {} is shorthand for an identifier context whose components are all empty.
6.1.4. Vectors

Vectors are written as plain sequences, but with a restriction on the length of these sequence.
​vec(A)​::=​(x:A)n​⇒​xn​(ifn<232)​​
6.2. Lexical Format
6.2.1. Characters

The text format assigns meaning to source text, which consists of a sequence of characters. Characters are assumed to be represented as valid [UNICODE] (Section 2.4) scalar values.
​sourcechar​::=::=​char∗U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​​

Note

While source text may contain any Unicode character in comments or string literals, the rest of the grammar is formed exclusively from the characters supported by the 7-bit ASCII subset of Unicode.
6.2.2. Tokens

The character stream in the source text is divided, from left to right, into a sequence of tokens, as defined by the following grammar.
​tokenkeywordreserved​::=::=::=​keyword ∣ uN ∣ sN ∣ fN ∣ string ∣ id ∣ ‘(’ ∣ ‘)’ ∣ reserved(‘a’ ∣ … ∣ ‘z’) idchar∗(if occurring as a literal terminal in the grammar)idchar+​​

Tokens are formed from the input character stream according to the longest match rule. That is, the next token always consists of the longest possible sequence of characters that is recognized by the above lexical grammar. Tokens can be separated by white space, but except for strings, they cannot themselves contain whitespace.

The set of keyword tokens is defined implicitly, by all occurrences of a terminal symbol in literal form, such as ‘keyword’, in a syntactic production of this chapter.

Any token that does not fall into any of the other categories is considered reserved, and cannot occur in source text.

Note

The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses or white space. For example, ‘0$x’ is a single reserved token. Consequently, it is not recognized as two separate tokens ‘0’ and ‘$x’, but instead disallowed. This property of tokenization is not affected by the fact that the definition of reserved tokens overlaps with other token classes.
6.2.3. White Space

White space is any sequence of literal space characters, formatting characters, or comments. The allowed formatting characters correspond to a subset of the ASCII format effectors, namely, horizontal tabulation (U+09), line feed (U+0A), and carriage return (U+0D).
​spaceformat​::=::=​(‘  ’ ∣ format ∣ comment)∗U+09 ∣ U+0A ∣ U+0D​​

The only relevance of white space is to separate tokens. It is otherwise ignored.
6.2.4. Comments

A comment can either be a line comment, started with a double semicolon ‘;;’ and extending to the end of the line, or a block comment, enclosed in delimiters ‘(;’…‘;)’. Block comments can be nested.
​commentlinecommentlinecharblockcommentblockchar​::=::=::=::=::=∣∣∣​linecomment ∣ blockcomment‘;;’  linechar∗  (U+0A ∣ eof)c:char‘(;’  blockchar∗  ‘;)’c:char‘;’‘(’blockcomment​(ifc​=U+0A)(ifc​=‘;’∧c​=‘(’)(if the next character is not ‘)’)(if the next character is not ‘;’)​​

Here, the pseudo token eof indicates the end of the input. The look-ahead restrictions on the productions for blockchar disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.

Note

Any formatting and control characters are allowed inside comments.
6.3. Values

The grammar productions in this section define lexical syntax, hence no white space is allowed.
6.3.1. Integers

All integers can be written in either decimal or hexadecimal notation. In both cases, digits can optionally be separated by underscores.
​signdigithexdigitnumhexnum​::=::=::=∣∣::=∣::=∣​ϵ⇒+  ∣  ‘+’⇒+  ∣  ‘−’⇒−‘0’⇒0  ∣  …  ∣  ‘9’⇒9d:digit⇒d‘A’⇒10  ∣  …  ∣  ‘F’⇒15‘a’⇒10  ∣  …  ∣  ‘f’⇒15d:digitn:num  ‘_’?  d:digith:hexdigitn:hexnum  ‘_’?  h:hexdigit​⇒⇒⇒⇒​d10⋅n+dh16⋅n+h​​

The allowed syntax for integer literals depends on size and signedness. Moreover, their value must lie within the range of the respective type.
​uNsN​::=∣::=∣​n:num‘0x’  n:hexnum±:sign  n:num±:sign  ‘0x’  n:hexnum​⇒⇒⇒⇒​nn±n±n​(ifn<2N)(ifn<2N)(if−2N−1≤±n<2N−1)(if−2N−1≤±n<2N−1)​​

Uninterpreted integers can be written as either signed or unsigned, and are normalized to unsigned in the abstract syntax.
​iN​::=∣​n:uNi:sN​⇒⇒​nn​(ifi=signed(n))​​
6.3.2. Floating-Point

Floating-point values can be represented in either decimal or hexadecimal notation.
​frachexfracfloathexfloat​::=∣∣::=∣∣::=∣∣∣::=∣∣∣​ϵd:digit  q:fracd:digit  ‘_’  p:digit  q:fracϵh:hexdigit  q:hexfrach:hexdigit  ‘_’    p:hexdigit  q:hexfracp:nump:num ‘.’ q:fracp:num (‘E’ ∣ ‘e’) ±:sign e:nump:num ‘.’ q:frac (‘E’ ∣ ‘e’) ±:sign e:num‘0x’ p:hexnum‘0x’ p:hexnum ‘.’ q:hexfrac‘0x’ p:hexnum (‘P’ ∣ ‘p’) ±:sign e:num‘0x’ p:hexnum ‘.’ q:hexfrac (‘P’ ∣ ‘p’) ±:sign e:num​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​0(d+q)/10(d+(p+q)/10)/100(h+q)/16(h+(p+q)/16)/16pp+qp⋅10±e(p+q)⋅10±epp+qp⋅2±e(p+q)⋅2±e​​

The value of a literal must not lie outside the representable range of the corresponding [IEEE-754-2019] type (that is, a numeric value must not overflow to ±infinity), but it may be rounded to the nearest representable value.

Note

Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by the required type.

Floating-point values may also be written as constants for infinity or canonical NaN (not a number). Furthermore, arbitrary NaN values may be expressed by providing an explicit payload value.
​fNfNmag​::=::=∣∣∣∣​±:sign z:fNmagz:floatz:hexfloat‘inf’‘nan’‘nan:0x’ n:hexnum​⇒⇒⇒⇒⇒⇒​±zfloatN​(z)floatN​(z)∞nan(2signif(N)−1)nan(n)​(iffloatN​(z)​=±∞)(iffloatN​(z)​=±∞)(if1≤n<2signif(N))​​
6.3.3. Strings

Strings denote sequences of bytes that can represent both textual and binary data. They are enclosed in quotation marks and may contain any character other than ASCII control characters, quotation marks (‘"’), or backslash (‘\’), except when expressed with an escape sequence.
​stringstringelem​::=::=∣​‘"’ (b∗:stringelem)∗ ‘"’c:stringchar‘\’ n:hexdigit m:hexdigit​⇒⇒⇒​concat((b∗)∗)utf8(c)16⋅n+m​(if∣concat((b∗)∗)∣<232)​

Each character in a string literal represents the byte sequence corresponding to its UTF-8 [UNICODE] (Section 2.5) encoding, except for hexadecimal escape sequences ‘\hh’, which represent raw bytes of the respective value.
​stringchar​::=∣∣∣∣∣∣∣​c:char‘\t’‘\n’‘\r’‘\"’‘\′’‘\\’‘\u{ n:hexnum ‘}’’​⇒⇒⇒⇒⇒⇒⇒⇒​cU+09U+0AU+0DU+22U+27U+5CU+(n)​(ifc≥U+20∧c​=U+7F∧c​=‘"’∧c​=‘\’)(ifn<0xD800∨0xE000≤n<0x110000)​​
6.3.4. Names

Names are strings denoting a literal character sequence. A name string must form a valid UTF-8 encoding as defined by [UNICODE] (Section 2.5) and is interpreted as a string of Unicode scalar values.
​name​::=​b∗:string​⇒​c∗​(ifb∗=utf8(c∗))​​

Note

Presuming the source text is itself encoded correctly, strings that do not contain any uses of hexadecimal byte escapes are always valid names.
6.3.5. Identifiers

Indices can be given in both numeric and symbolic form. Symbolic identifiers that stand in lieu of indices start with ‘$’, followed by any sequence of printable ASCII characters that does not contain a space, quotation mark, comma, semicolon, or bracket.
​ididchar​::=::=∣∣∣∣​‘$’ idchar+‘0’  ∣  …  ∣  ‘9’‘A’  ∣  …  ∣  ‘Z’‘a’  ∣  …  ∣  ‘z’‘!’  ∣  ‘#’  ∣  ‘$’  ∣  ‘%’  ∣  ‘&’  ∣  ‘′’  ∣  ‘∗’  ∣  ‘+’  ∣  ‘−’  ∣  ‘.’  ∣  ‘/’‘:’  ∣  ‘<’  ∣  ‘=’  ∣  ‘>’  ∣  ‘?’  ∣  ‘@’  ∣  ‘\’  ∣  ‘  ^’  ∣  ‘_’  ∣  ‘  ˋ’  ∣  ‘∣’  ∣  ‘  ~’​​
6.3.5.1. Conventions

The expansion rules of some abbreviations require insertion of a fresh identifier. That may be any syntactically valid identifier that does not already occur in the given source text.
6.4. Types
6.4.1. Value Types
​valtype​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​i32i64f32f64​​
6.4.2. Function Types
​functypeparamresult​::=::=::=​‘(’ ‘func’  t1∗​:vec(param)  t2∗​:vec(result) ‘)’‘(’ ‘param’  id?  t:valtype ‘)’‘(’ ‘result’  t:valtype ‘)’​⇒⇒⇒​[t1∗​]→[t2∗​]tt​​
6.4.2.1. Abbreviations

Multiple anonymous parameters or results may be combined into a single declaration:
​‘(’  ‘param’  valtype∗  ‘)’‘(’  ‘result’  valtype∗  ‘)’​≡≡​(‘(’  ‘param’  valtype  ‘)’)∗(‘(’  ‘result’  valtype  ‘)’)∗​​
6.4.3. Limits
​limits​::=∣​n:u32n:u32  m:u32​⇒⇒​{min n,max ϵ}{min n,max m}​​
6.4.4. Memory Types
​memtype​::=​lim:limits​⇒​lim​​
6.4.5. Table Types
​tabletypeelemtype​::=::=​lim:limits  et:elemtype‘funcref’​⇒⇒​lim etfuncref​​

Note

Additional element types may be introduced in future versions of WebAssembly.
6.4.6. Global Types
​globaltype​::=∣​t:valtype‘(’ ‘mut’  t:valtype ‘)’​⇒⇒​const tvar t​​
6.5. Instructions

Instructions are syntactically distinguished into plain and structured instructions.
​instrI​​::=∣​in:plaininstrI​in:blockinstrI​​⇒⇒​inin​​

In addition, as a syntactic abbreviation, instructions can be written as S-expressions in folded form, to group them visually.
6.5.1. Labels

Structured control instructions can be annotated with a symbolic label identifier. They are the only symbolic identifiers that can be bound locally in an instruction sequence. The following grammar handles the corresponding update to the identifier context by composing the context with an additional label entry.
​labelI​​::=∣​v:idϵ​⇒⇒​{labels v}⊕I{labels (ϵ)}⊕I​(ifv∈/​I.labels)​

Note

The new label entry is inserted at the beginning of the label list in the identifier context. This effectively shifts all existing labels up by one, mirroring the fact that control instructions are indexed relatively not absolutely.
6.5.2. Control Instructions

Structured control instructions can bind an optional symbolic label identifier. The same label identifier may optionally be repeated after the corresponding end and else pseudo instructions, to indicate the matching delimiters.

Their block type is given as a type use, analogous to the type of functions. However, the special case of a type use that is syntactically empty or consists of only a single result is not regarded as an abbreviation for an inline function type, but is parsed directly into an optional value type.
​blocktypeI​blockinstrI​​::=∣​::=∣∣​(t:result)?x,I′:typeuseI​​⇒⇒​t?x​(ifI′={})​‘block’  I′:labelI​  bt:blocktype  (in:instrI′​)∗  ‘end’  id?⇒block bt in∗ end  (ifid?=ϵ∨id?=label)‘loop’  I′:labelI​  bt:blocktype  (in:instrI′​)∗  ‘end’  id?⇒loop bt in∗ end(ifid?=ϵ∨id?=label)‘if’  I′:labelI​  bt:blocktype  (in1​:instrI′​)∗  ‘else’  id1?​  (in2​:instrI′​)∗  ‘end’  id2?​⇒if bt in1∗​ else in2∗​ end(ifid1?​=ϵ∨id1?​=label,id2?​=ϵ∨id2?​=label)​​

Note

The side condition stating that the identifier context I′ must be empty in the rule for typeuse block types enforces that no identifier can be bound in any param declaration for a block type.

All other control instruction are represented verbatim.
​plaininstrI​​::=∣∣∣∣∣∣∣​‘unreachable’‘nop’‘br’  l:labelidxI​‘br_if’  l:labelidxI​‘br_table’  l∗:vec(labelidxI​)  lN​:labelidxI​‘return’‘call’  x:funcidxI​‘call_indirect’  x,I′:typeuseI​​⇒⇒⇒⇒⇒⇒⇒⇒​unreachablenopbr lbr_if lbr_table l∗ lN​returncall xcall_indirect x​(ifI′={})​​

Note

The side condition stating that the identifier context I′ must be empty in the rule for call_indirect enforces that no identifier can be bound in any param declaration appearing in the type annotation.
6.5.2.1. Abbreviations

The ‘else’ keyword of an ‘if’ instruction can be omitted if the following instruction sequence is empty.
​‘if’  label  blocktype  instr∗  ‘end’​≡​‘if’  label  blocktype  instr∗  ‘else’  ‘end’​
6.5.3. Parametric Instructions
​plaininstrI​​::=∣∣​…‘drop’‘select’​⇒⇒​dropselect​​
6.5.4. Variable Instructions
​plaininstrI​​::=∣∣∣∣∣​…‘local.get’  x:localidxI​‘local.set’  x:localidxI​‘local.tee’  x:localidxI​‘global.get’  x:globalidxI​‘global.set’  x:globalidxI​​⇒⇒⇒⇒⇒​local.get xlocal.set xlocal.tee xglobal.get xglobal.set x​​
6.5.5. Memory Instructions

The offset and alignment immediates to memory instructions are optional. The offset defaults to 0, the alignment to the storage size of the respective memory access, which is its natural alignment. Lexically, an offset or align phrase is considered a single keyword token, so no white space is allowed around the ‘=’.
​memargN​offsetalignN​plaininstrI​​::=::=∣::=∣::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​o:offset  a:alignN​‘offset=’o:u32ϵ‘align=’a:u32ϵ…‘i32.load’  m:memarg4​‘i64.load’  m:memarg8​‘f32.load’  m:memarg4​‘f64.load’  m:memarg8​‘i32.load8_s’  m:memarg1​‘i32.load8_u’  m:memarg1​‘i32.load16_s’  m:memarg2​‘i32.load16_u’  m:memarg2​‘i64.load8_s’  m:memarg1​‘i64.load8_u’  m:memarg1​‘i64.load16_s’  m:memarg2​‘i64.load16_u’  m:memarg2​‘i64.load32_s’  m:memarg4​‘i64.load32_u’  m:memarg4​‘i32.store’  m:memarg4​‘i64.store’  m:memarg8​‘f32.store’  m:memarg4​‘f64.store’  m:memarg8​‘i32.store8’  m:memarg1​‘i32.store16’  m:memarg2​‘i64.store8’  m:memarg1​‘i64.store16’  m:memarg2​‘i64.store32’  m:memarg4​‘memory.size’‘memory.grow’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​{align n, offset o}o0aNi32.load mi64.load mf32.load mf64.load mi32.load8_s mi32.load8_u mi32.load16_s mi32.load16_u mi64.load8_s mi64.load8_u mi64.load16_s mi64.load16_u mi64.load32_s mi64.load32_u mi32.store mi64.store mf32.store mf64.store mi32.store8 mi32.store16 mi64.store8 mi64.store16 mi64.store32 mmemory.sizememory.grow​(ifa=2n)​
6.5.6. Numeric Instructions
​plaininstrI​​::=∣∣∣∣​…‘i32.const’  n:i32‘i64.const’  n:i64‘f32.const’  z:f32‘f64.const’  z:f64​⇒⇒⇒⇒​i32.const ni64.const nf32.const zf64.const z​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘i32.clz’‘i32.ctz’‘i32.popcnt’‘i32.add’‘i32.sub’‘i32.mul’‘i32.div_s’‘i32.div_u’‘i32.rem_s’‘i32.rem_u’‘i32.and’‘i32.or’‘i32.xor’‘i32.shl’‘i32.shr_s’‘i32.shr_u’‘i32.rotl’‘i32.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.clzi32.ctzi32.popcnti32.addi32.subi32.muli32.div_si32.div_ui32.rem_si32.rem_ui32.andi32.ori32.xori32.shli32.shr_si32.shr_ui32.rotli32.rotr​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘i64.clz’‘i64.ctz’‘i64.popcnt’‘i64.add’‘i64.sub’‘i64.mul’‘i64.div_s’‘i64.div_u’‘i64.rem_s’‘i64.rem_u’‘i64.and’‘i64.or’‘i64.xor’‘i64.shl’‘i64.shr_s’‘i64.shr_u’‘i64.rotl’‘i64.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi64.clzi64.ctzi64.popcnti64.addi64.subi64.muli64.div_si64.div_ui64.rem_si64.rem_ui64.andi64.ori64.xori64.shli64.shr_si64.shr_ui64.rotli64.rotr​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘f32.abs’‘f32.neg’‘f32.ceil’‘f32.floor’‘f32.trunc’‘f32.nearest’‘f32.sqrt’‘f32.add’‘f32.sub’‘f32.mul’‘f32.div’‘f32.min’‘f32.max’‘f32.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf32.absf32.negf32.ceilf32.floorf32.truncf32.nearestf32.sqrtf32.addf32.subf32.mulf32.divf32.minf32.maxf32.copysign​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘f64.abs’‘f64.neg’‘f64.ceil’‘f64.floor’‘f64.trunc’‘f64.nearest’‘f64.sqrt’‘f64.add’‘f64.sub’‘f64.mul’‘f64.div’‘f64.min’‘f64.max’‘f64.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf64.absf64.negf64.ceilf64.floorf64.truncf64.nearestf64.sqrtf64.addf64.subf64.mulf64.divf64.minf64.maxf64.copysign​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘i32.eqz’‘i32.eq’‘i32.ne’‘i32.lt_s’‘i32.lt_u’‘i32.gt_s’‘i32.gt_u’‘i32.le_s’‘i32.le_u’‘i32.ge_s’‘i32.ge_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.eqzi32.eqi32.nei32.lt_si32.lt_ui32.gt_si32.gt_ui32.le_si32.le_ui32.ge_si32.ge_u​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘i64.eqz’‘i64.eq’‘i64.ne’‘i64.lt_s’‘i64.lt_u’‘i64.gt_s’‘i64.gt_u’‘i64.le_s’‘i64.le_u’‘i64.ge_s’‘i64.ge_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi64.eqzi64.eqi64.nei64.lt_si64.lt_ui64.gt_si64.gt_ui64.le_si64.le_ui64.ge_si64.ge_u​​
​plaininstrI​​::=∣∣∣∣∣∣​thisisenough‘f32.eq’‘f32.ne’‘f32.lt’‘f32.gt’‘f32.le’‘f32.ge’​⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf32.eqf32.nef32.ltf32.gtf32.lef32.ge​​
​plaininstrI​​::=∣∣∣∣∣∣​thisisenough‘f64.eq’‘f64.ne’‘f64.lt’‘f64.gt’‘f64.le’‘f64.ge’​⇒⇒⇒⇒⇒⇒​thisshouldbeenoughf64.eqf64.nef64.ltf64.gtf64.lef64.ge​​
​plaininstrI​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​thisisenough‘i32.wrap_i64’‘i32.trunc_f32_s’‘i32.trunc_f32_u’‘i32.trunc_f64_s’‘i32.trunc_f64_u’‘i32.trunc_satf​32_s’‘i32.trunc_satf​32_u’‘i32.trunc_satf​64_s’‘i32.trunc_satf​64_u’‘i64.extend_i32_s’‘i64.extend_i32_u’‘i64.trunc_f32_s’‘i64.trunc_f32_u’‘i64.trunc_f64_s’‘i64.trunc_f64_u’‘i64.trunc_satf​32_s’‘i64.trunc_satf​32_u’‘i64.trunc_satf​64_s’‘i64.trunc_satf​64_u’‘f32.convert_i32_s’‘f32.convert_i32_u’‘f32.convert_i64_s’‘f32.convert_i64_u’‘f32.demote_f64’‘f64.convert_i32_s’‘f64.convert_i32_u’‘f64.convert_i64_s’‘f64.convert_i64_u’‘f64.promote_f32’‘i32.reinterpret_f32’‘i64.reinterpret_f64’‘f32.reinterpret_i32’‘f64.reinterpret_i64’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​thisshouldbeenoughi32.wrap_i64i32.trunc_f32_si32.trunc_f32_ui32.trunc_f64_si32.trunc_f64_ui32.trunc_sat_f32_si32.trunc_sat_f32_ui32.trunc_sat_f64_si32.trunc_sat_f64_ui64.extend_i32_si64.extend_i32_ui64.trunc_f32_si64.trunc_f32_ui64.trunc_f64_si64.trunc_f64_ui64.trunc_sat_f32_si64.trunc_sat_f32_ui64.trunc_sat_f64_si64.trunc_sat_f64_uf32.convert_i32_sf32.convert_i32_uf32.convert_i64_sf32.convert_i64_uf32.demote_f64f64.convert_i32_sf64.convert_i32_uf64.convert_i64_sf64.convert_i64_uf64.promote_f32i32.reinterpret_f32i64.reinterpret_f64f32.reinterpret_i32f64.reinterpret_i64​​
​plaininstrI​​::=∣∣∣∣∣​thisisenough‘i32.extend8_s’‘i32.extend16_s’‘i64.extend8_s’‘i64.extend16_s’‘i64.extend32_s’​⇒⇒⇒⇒⇒​thisshouldbeenoughi32.extend8_si32.extend16_si64.extend8_si64.extend16_si64.extend32_s​​
6.5.7. Folded Instructions

Instructions can be written as S-expressions by grouping them into folded form. In that notation, an instruction is wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.

In the case of block instructions, the folded form omits the ‘end’ delimiter. For if instructions, both branches have to be wrapped into nested S-expressions, headed by the keywords ‘then’ and ‘else’.

The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class foldedinstr. Such a folded instruction can appear anywhere a regular instruction can.
​‘(’ plaininstr  foldedinstr∗ ‘)’‘(’ ‘block’  label  blocktype  instr∗ ‘)’‘(’ ‘loop’  label  blocktype  instr∗ ‘)’‘(’ ‘if’  label  blocktype  foldedinstr∗foldedinstr∗  ‘if’  label  blocktype​≡foldedinstr∗  plaininstr≡‘block’  label  blocktype  instr∗  ‘end’≡‘loop’  label  blocktype  instr∗  ‘end’‘(’ ‘then’  instr1∗​ ‘)’  ‘(’ ‘else’  instr2∗​ ‘)’?  ‘)’≡instr1∗​  ‘else’  (instr2∗​)? ‘end’​​

Note

For example, the instruction sequence
(local.get $x) (i32.const 2) i32.add (i32.const 3) i32.mul

can be folded into
(i32.mul (i32.add (local.get $x) (i32.const 2)) (i32.const 3))

Folded instructions are solely syntactic sugar, no additional syntactic or type-based checking is implied.
6.5.8. Expressions

Expressions are written as instruction sequences. No explicit ‘end’ keyword is included, since they only occur in bracketed positions.
​expr​::=​(in:instr)∗​⇒​in∗ end​​
6.6. Modules
6.6.1. Indices

Indices can be given either in raw numeric form or as symbolic identifiers when bound by a respective construct. Such identifiers are looked up in the suitable space of the identifier context I.
​typeidxI​funcidxI​tableidxI​memidxI​globalidxI​localidxI​labelidxI​​::=∣::=∣::=∣::=∣::=∣::=∣::=∣​x:u32v:idx:u32v:idx:u32v:idx:u32v:idx:u32v:idx:u32v:idl:u32v:id​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​xxxxxxxxxxxxll​(ifI.types[x]=v)(ifI.funcs[x]=v)(ifI.tables[x]=v)(ifI.mems[x]=v)(ifI.globals[x]=v)(ifI.locals[x]=v)(ifI.labels[l]=v)​​
6.6.2. Types

Type definitions can bind a symbolic type identifier.
​type​::=​‘(’ ‘type’  id?  ft:functype ‘)’​⇒​ft​​
6.6.3. Type Uses

A type use is a reference to a type definition. It may optionally be augmented by explicit inlined parameter and result declarations. That allows binding symbolic identifiers to name the local indices of parameters. If inline declarations are given, then their types must match the referenced function type.
​typeuseI​​::=∣​‘(’ ‘type’  x:typeidxI​ ‘)’⇒x,I′(ifI.typedefs[x]=[t1n​]→[t2∗​]∧I′={locals (ϵ)n})​‘(’ ‘type’  x:typeidxI​ ‘)’  (t1​:param)∗  (t2​:result)∗⇒x,I′(ifI.typedefs[x]=[t1∗​]→[t2∗​]∧I′={locals id(param)∗} well-formed)​​​

The synthesized attribute of a typeuse is a pair consisting of both the used type index and the updated identifier context including possible parameter identifiers. The following auxiliary function extracts optional identifiers from parameters:
id(‘(’ ‘param’ id? … ‘)’)​=​id?​​

Note

Both productions overlap for the case that the function type is []→[]. However, in that case, they also produce the same results, so that the choice is immaterial.

The well-formedness condition on I′ ensures that the parameters do not contain duplicate identifier.
6.6.3.1. Abbreviations

A typeuse may also be replaced entirely by inline parameter and result declarations. In that case, a type index is automatically inserted:
​(t1​:param)∗  (t2​:result)∗​≡​‘(’ ‘type’  x ‘)’  param∗  result∗​​

where x is the smallest existing type index whose definition in the current module is the function type [t1∗​]→[t2∗​]. If no such index exists, then a new type definition of the form
‘(’ ‘type’  ‘(’ ‘func’  param∗  result ‘)’ ‘)’

is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by consecutive expansions.
6.6.4. Imports

The descriptors in imports can bind a symbolic function, table, memory, or global identifier.
​importI​importdescI​​::=::=∣∣∣​‘(’ ‘import’  mod:name  nm:name  d:importdescI​ ‘)’⇒{module mod,name nm,desc d}‘(’ ‘func’  id?  x,I′:typeuseI​ ‘)’‘(’ ‘table’  id?  tt:tabletype ‘)’‘(’ ‘memory’  id?  mt:memtype ‘)’‘(’ ‘global’  id?  gt:globaltype ‘)’​⇒⇒⇒⇒​func xtable ttmem  mtglobal gt​​
6.6.4.1. Abbreviations

As an abbreviation, imports may also be specified inline with function, table, memory, or global definitions; see the respective sections.
6.6.5. Functions

Function definitions can bind a symbolic function identifier, and local identifiers for its parameters and locals.
​funcI​local​::=::=​‘(’ ‘func’  id?  x,I′:typeuseI​  (t:local)∗  (in:instrI′′​)∗ ‘)’⇒{type x,locals t∗,body in∗ end}(ifI′′=I′⊕{locals id(local)∗} well-formed)‘(’ ‘local’  id?  t:valtype ‘)’⇒t​​

The definition of the local identifier context I′′ uses the following auxiliary function to extract optional identifiers from locals:
id(‘(’ ‘local’ id? … ‘)’)​=​id?​​

Note

The well-formedness condition on I′′ ensures that parameters and locals do not contain duplicate identifiers.
6.6.5.1. Abbreviations

Multiple anonymous locals may be combined into a single declaration:
​‘(’  ‘local’  valtype∗  ‘)’​≡​(‘(’  ‘local’  valtype  ‘)’)∗​​

Functions can be defined as imports or exports inline:
​‘(’ ‘func’  id?  ‘(’ ‘import’  name1​  name2​ ‘)’  typeuse ‘)’≡‘(’ ‘import’  name1​  name2​  ‘(’ ‘func’  id?  typeuse ‘)’ ‘)’‘(’ ‘func’  id?  ‘(’ ‘export’  name ‘)’  … ‘)’≡‘(’ ‘export’  name  ‘(’ ‘func’  id′ ‘)’ ‘)’  ‘(’ ‘func’  id′  … ‘)’(ifid′=id?​=ϵ∨id′ fresh)​​

The latter abbreviation can be applied repeatedly, with “…” containing another import or export.
6.6.6. Tables

Table definitions can bind a symbolic table identifier.
​tableI​​::=​‘(’ ‘table’  id?  tt:tabletype ‘)’​⇒​{type tt}​​
6.6.6.1. Abbreviations

An element segment can be given inline with a table definition, in which case its offset is 0 and the limits of the table type are inferred from the length of the given segment:
​‘(’ ‘table’  id?  elemtype  ‘(’ ‘elem’  xn:vec(funcidx) ‘)’  ‘)’≡‘(’ ‘table’  id′  n  n  elemtype ‘)’  ‘(’ ‘elem’  id′  ‘(’ ‘i32.const’  ‘0’ ‘)’  vec(funcidx) ‘)’(ifid′=id?​=ϵ∨id′ fresh)​​

Tables can be defined as imports or exports inline:
​‘(’ ‘table’  id?  ‘(’ ‘import’  name1​  name2​ ‘)’  tabletype ‘)’≡‘(’ ‘import’  name1​  name2​  ‘(’ ‘table’  id?  tabletype ‘)’ ‘)’‘(’ ‘table’  id?  ‘(’ ‘export’  name ‘)’  … ‘)’≡‘(’ ‘export’  name  ‘(’ ‘table’  id′ ‘)’ ‘)’  ‘(’ ‘table’  id′  … ‘)’(ifid′=id?​=ϵ∨id′ fresh)​​

The latter abbreviation can be applied repeatedly, with “…” containing another import or export or an inline elements segment.
6.6.7. Memories

Memory definitions can bind a symbolic memory identifier.
​memI​​::=​‘(’ ‘memory’  id?  mt:memtype ‘)’​⇒​{type mt}​​
6.6.7.1. Abbreviations

A data segment can be given inline with a memory definition, in which case its offset is 0 the limits of the memory type are inferred from the length of the data, rounded up to page size:
​‘(’ ‘memory’  id?  ‘(’ ‘data’  bn:datastring ‘)’  ‘)’≡‘(’ ‘memory’  id′  m  m ‘)’  ‘(’ ‘data’  id′  ‘(’ ‘i32.const’  ‘0’ ‘)’  datastring ‘)’(ifid′=id?​=ϵ∨id′ fresh,m=ceil(n/64Ki))​​

Memories can be defined as imports or exports inline:
​‘(’ ‘memory’  id?  ‘(’ ‘import’  name1​  name2​ ‘)’  memtype ‘)’≡‘(’ ‘import’  name1​  name2​  ‘(’ ‘memory’  id?  memtype ‘)’ ‘)’‘(’ ‘memory’  id?  ‘(’ ‘export’  name ‘)’  … ‘)’≡‘(’ ‘export’  name  ‘(’ ‘memory’  id′ ‘)’ ‘)’  ‘(’ ‘memory’  id′  … ‘)’(ifid′=id?​=ϵ∨id′ fresh)​​

The latter abbreviation can be applied repeatedly, with “…” containing another import or export or an inline data segment.
6.6.8. Globals

Global definitions can bind a symbolic global identifier.
​globalI​​::=​‘(’ ‘global’  id?  gt:globaltype  e:exprI​ ‘)’​⇒​{type gt,init e}​​
6.6.8.1. Abbreviations

Globals can be defined as imports or exports inline:
​‘(’ ‘global’  id?  ‘(’ ‘import’  name1​  name2​ ‘)’  globaltype ‘)’≡‘(’ ‘import’  name1​  name2​  ‘(’ ‘global’  id?  globaltype ‘)’ ‘)’‘(’ ‘global’  id?  ‘(’ ‘export’  name ‘)’  … ‘)’≡‘(’ ‘export’  name  ‘(’ ‘global’  id′ ‘)’ ‘)’  ‘(’ ‘global’  id′  … ‘)’(ifid′=id?​=ϵ∨id′ fresh)​​

The latter abbreviation can be applied repeatedly, with “…” containing another import or export.
6.6.9. Exports

The syntax for exports mirrors their abstract syntax directly.
​exportI​exportdescI​​::=::=∣∣∣​‘(’ ‘export’  nm:name  d:exportdescI​ ‘)’‘(’ ‘func’  x:funcidxI​ ‘)’‘(’ ‘table’  x:tableidxI​ ‘)’‘(’ ‘memory’  x:memidxI​ ‘)’‘(’ ‘global’  x:globalidxI​ ‘)’​⇒⇒⇒⇒⇒​{name nm,desc d}func xtable xmem xglobal x​​
6.6.9.1. Abbreviations

As an abbreviation, exports may also be specified inline with function, table, memory, or global definitions; see the respective sections.
6.6.10. Start Function

A start function is defined in terms of its index.
​startI​​::=​‘(’ ‘start’  x:funcidxI​ ‘)’​⇒​{func x}​​

Note

At most one start function may occur in a module, which is ensured by a suitable side condition on the module grammar.
6.6.11. Element Segments

Element segments allow for an optional table index to identify the table to initialize.
​elemI​​::=​‘(’ ‘elem’  x:tableidxI​  ‘(’ ‘offset’  e:exprI​ ‘)’  y∗:vec(funcidxI​) ‘)’⇒{table x,offset e,init y∗}​​

Note

In the current version of WebAssembly, the only valid table index is 0 or a symbolic table identifier resolving to the same value.
6.6.11.1. Abbreviations

As an abbreviation, a single instruction may occur in place of the offset:
​instr​≡​‘(’ ‘offset’  instr ‘)’​

Also, the table index can be omitted, defaulting to 0.
​‘(’ ‘elem’  ‘(’ ‘offset’  exprI​ ‘)’  … ‘)’​≡​‘(’ ‘elem’  0  ‘(’ ‘offset’  exprI​ ‘)’  … ‘)’​

As another abbreviation, element segments may also be specified inline with table definitions; see the respective section.
6.6.12. Data Segments

Data segments allow for an optional memory index to identify the memory to initialize. The data is written as a string, which may be split up into a possibly empty sequence of individual string literals.
​dataI​datastring​::=::=​‘(’ ‘data’  x:memidxI​  ‘(’ ‘offset’  e:exprI​ ‘)’  b∗:datastring ‘)’⇒{data x′,offset e,init b∗}(b∗:string)∗⇒concat((b∗)∗)​​

Note

In the current version of WebAssembly, the only valid memory index is 0 or a symbolic memory identifier resolving to the same value.
6.6.12.1. Abbreviations

As an abbreviation, a single instruction may occur in place of the offset:
​instr​≡​‘(’ ‘offset’  instr ‘)’​

Also, the memory index can be omitted, defaulting to 0.
​‘(’ ‘data’  ‘(’ ‘offset’  exprI​ ‘)’  … ‘)’​≡​‘(’ ‘data’  0  ‘(’ ‘offset’  exprI​ ‘)’  … ‘)’​

As another abbreviation, data segments may also be specified inline with memory definitions; see the respective section.
6.6.13. Modules

A module consists of a sequence of fields that can occur in any order. All definitions and their respective bound identifiers scope over the entire module, including the text preceding them.

A module may optionally bind an identifier that names the module. The name serves a documentary role only.

Note

Tools may include the module name in the name section of the binary format.
​modulemodulefieldI​​::=​‘(’ ‘module’  id?  (m:modulefieldI​)∗ ‘)’⇒⨁m∗(ifI=⨁idc(modulefield)∗ well-formed)​::=∣∣∣∣∣∣∣∣∣​ty:typeim:importI​fn:funcI​ta:tableI​me:memI​gl:globalI​ex:exportI​st:startI​el:elemI​da:dataI​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​{types ty}{imports im}{funcs fn}{tables ta}{mems me}{globals gl}{exports ex}{start st}{elem el}{data da}​​​

The following restrictions are imposed on the composition of modules: m1​⊕m2​ is defined if and only if

    m1​.start=ϵ∨m2​.start=ϵ

    m1​.funcs=m1​.tables=m1​.mems=m1​.globals=ϵ∨m2​.imports=ϵ

Note

The first condition ensures that there is at most one start function. The second condition enforces that all imports must occur before any regular definition of a function, table, memory, or global, thereby maintaining the ordering of the respective index spaces.

The well-formedness condition on I in the grammar for module ensures that no namespace contains duplicate identifiers.

The definition of the initial identifier context I uses the following auxiliary definition which maps each relevant definition to a singular context with one (possibly empty) identifier:
idc(‘(’ ‘type’ id? ft:functype ‘)’)idc(‘(’ ‘func’ id? … ‘)’)idc(‘(’ ‘table’ id? … ‘)’)idc(‘(’ ‘memory’ id? … ‘)’)idc(‘(’ ‘global’ id? … ‘)’)idc(‘(’ ‘import’ … ‘(’ ‘func’ id? … ‘)’ ‘)’)idc(‘(’ ‘import’ … ‘(’ ‘table’ id? … ‘)’ ‘)’)idc(‘(’ ‘import’ … ‘(’ ‘memory’ id? … ‘)’ ‘)’)idc(‘(’ ‘import’ … ‘(’ ‘global’ id? … ‘)’ ‘)’)idc(‘(’ … ‘)’)​==========​{types (id?),typedefs ft}{funcs (id?)}{tables (id?)}{mems (id?)}{globals (id?)}{funcs (id?)}{tables (id?)}{mems (id?)}{globals (id?)}{}​​
6.6.13.1. Abbreviations

In a source file, the toplevel (module …) surrounding the module body may be omitted.
​modulefield∗​≡​‘(’ ‘module’  modulefield∗ ‘)’​
A Appendix
A.1 Embedding

A WebAssembly implementation will typically be embedded into a host environment. An embedder implements the connection between such a host environment and the WebAssembly semantics as defined in the main body of this specification. An embedder is expected to interact with the semantics in well-defined ways.

This section defines a suitable interface to the WebAssembly semantics in the form of entry points through which an embedder can access it. The interface is intended to be complete, in the sense that an embedder does not need to reference other functional parts of the WebAssembly specification directly.

Note

On the other hand, an embedder does not need to provide the host environment with access to all functionality defined in this interface. For example, an implementation may not support parsing of the text format.
Types

In the description of the embedder interface, syntactic classes from the abstract syntax and the runtime’s abstract machine are used as names for variables that range over the possible objects from that class. Hence, these syntactic classes can also be interpreted as types.

For numeric parameters, notation like n:u32 is used to specify a symbolic name in addition to the respective value range.
Errors

Failure of an interface operation is indicated by an auxiliary syntactic class:
​error​::=​error​​

In addition to the error conditions specified explicitly in this section, implementations may also return errors when specific implementation limitations are reached.

Note

Errors are abstract and unspecific with this definition. Implementations can refine it to carry suitable classifications and diagnostic messages.
Pre- and Post-Conditions

Some operations state pre-conditions about their arguments or post-conditions about their results. It is the embedder’s responsibility to meet the pre-conditions. If it does, the post conditions are guaranteed by the semantics.

In addition to pre- and post-conditions explicitly stated with each operation, the specification adopts the following conventions for runtime objects (store, moduleinst, externval, addresses):

    Every runtime object passed as a parameter must be valid per an implicit pre-condition.

    Every runtime object returned as a result is valid per an implicit post-condition.

Note

As long as an embedder treats runtime objects as abstract and only creates and manipulates them through the interface defined here, all implicit pre-conditions are automatically met.
Store
store_init():store

    Return the empty store.

store_init()​=​{funcs ϵ, mems ϵ, tables ϵ, globals ϵ}​​
Modules
module_decode(byte∗):module ∣ error

    If there exists a derivation for the byte sequence byte∗ as a module according to the binary grammar for modules, yielding a module m, then return m.

    Else, return error.

module_decode(b∗)module_decode(b∗)​==​merror​​(ifmodule⟹∗​m:b∗)(otherwise)​​
module_parse(char∗):module ∣ error

    If there exists a derivation for the source char∗ as a module according to the text grammar for modules, yielding a module m, then return m.

    Else, return error.

module_parse(c∗)module_parse(c∗)​==​merror​​(ifmodule⟹∗​m:c∗)(otherwise)​​
module_validate(module):error?

    If module is valid, then return nothing.

    Else, return error.

module_validate(m)module_validate(m)​==​ϵerror​​(if⊢m:externtype∗→externtype′∗)(otherwise)​​
module_instantiate(store,module,externval∗):(store,moduleinst ∣ error)

    Try instantiating module in store with external values externval∗ as imports:

        If it succeeds with a module instance moduleinst, then let result be moduleinst.

        Else, let result be error.

    Return the new store paired with result.

module_instantiate(S,m,ev∗)module_instantiate(S,m,ev∗)​==​(S′,F.module)(S′,error)​​(ifinstantiate(S,m,ev∗)↪∗S′;F;ϵ)(ifinstantiate(S,m,ev∗)↪∗S′;F;trap)​​

Note

The store may be modified even in case of an error.
module_imports(module):(name,name,externtype)∗

    Pre-condition: module is valid with external import types externtype∗ and external export types externtype′∗.

    Let import∗ be the imports module.imports.

    Assert: the length of import∗ equals the length of externtype∗.

    For each importi​ in import∗ and corresponding externtypei​ in externtype∗, do:

        Let resulti​ be the triple (importi​.module,importi​.name,externtypei​).

    Return the concatenation of all resulti​, in index order.

    Post-condition: each externtypei​ is valid.

 module_imports(m)​=​(im.module,im.name,externtype)∗(ifim∗=m.imports∧⊢m:externtype∗→externtype′∗)​​
module_exports(module):(name,externtype)∗

    Pre-condition: module is valid with external import types externtype∗ and external export types externtype′∗.

    Let export∗ be the exports module.exports.

    Assert: the length of export∗ equals the length of externtype′∗.

    For each exporti​ in export∗ and corresponding externtypei′​ in externtype′∗, do:

        Let resulti​ be the pair (exporti​.name,externtypei′​).

    Return the concatenation of all resulti​, in index order.

    Post-condition: each externtypei′​ is valid.

 module_exports(m)​=​(ex.name,externtype′)∗(ifex∗=m.exports∧⊢m:externtype∗→externtype′∗)​​
Module Instances
instance_export(moduleinst,name):externval ∣ error

    Assert: due to validity of the module instance moduleinst, all its export names are different.

    If there exists an exportinsti​ in moduleinst.exports such that name exportinsti​.name equals name, then:

        Return the external value exportinsti​.value.

    Else, return error.

 instance_export(m,name)instance_export(m,name)​==​m.exports[i].valueerror​​(ifm.exports[i].name=name)(otherwise)​​
Functions
func_alloc(store,functype,hostfunc):(store,funcaddr)

    Pre-condition: functype is valid<valid−functype>.

    Let funcaddr be the result of allocating a host function in store with function type functype and host function code hostfunc.

    Return the new store paired with funcaddr.

func_alloc(S,ft,code)​=​(S′,a)​​(ifallochostfunc(S,ft,code)=S′,a)​​

Note

This operation assumes that hostfunc satisfies the pre- and post-conditions required for a function instance with type functype.

Regular (non-host) function instances can only be created indirectly through module instantiation.
func_type(store,funcaddr):functype

    Assert: the external value func funcaddr is valid with external type func functype.

    Return functype.

    Post-condition: functype is valid.

func_type(S,a)​=​ft​​(ifS⊢func a:func ft)​​
func_invoke(store,funcaddr,val∗):(store,val∗ ∣ error)

    Try invoking the function funcaddr in store with values val∗ as arguments:

        If it succeeds with values val′∗ as results, then let result be val′∗.

        Else it has trapped, hence let result be error.

    Return the new store paired with result.

 func_invoke(S,a,v∗)func_invoke(S,a,v∗)​==​(S′,v′∗)(S′,error)​​(ifinvoke(S,a,v∗)↪∗S′;F;v′∗)(ifinvoke(S,a,v∗)↪∗S′;F;trap)​​

Note

The store may be modified even in case of an error.
Tables
table_alloc(store,tabletype):(store,tableaddr)

    Pre-condition: tabletype is valid<valid−tabletype>.

    Let tableaddr be the result of allocating a table in store with table type tabletype.

    Return the new store paired with tableaddr.

table_alloc(S,tt)​=​(S′,a)​​(ifalloctable(S,tt)=S′,a)​​
table_type(store,tableaddr):tabletype

    Assert: the external value table tableaddr is valid with external type table tabletype.

    Return tabletype.

    Post-condition: tabletype is valid<valid−tabletype>.

table_type(S,a)​=​tt​​(ifS⊢table a:table tt)​​
table_read(store,tableaddr,i:u32):funcaddr? ∣ error

    Let ti be the table instance store.tables[tableaddr].

    If i is larger than or equal to the length of ti.elem, then return error.

    Else, return ti.elem[i].

table_read(S,a,i)table_read(S,a,i)​==​fa?error​​(ifS.tables[a].elem[i]=fa?)(otherwise)​​
table_write(store,tableaddr,i:u32,funcaddr?):store ∣ error

    Let ti be the table instance store.tables[tableaddr].

    If i is larger than or equal to the length of ti.elem, then return error.

    Replace ti.elem[i] with the optional function address fa?.

    Return the updated store.

table_write(S,a,i,fa?)table_write(S,a,i,fa?)​==​S′error​​(ifS′=Swithtables[a].elem[i]=fa?)(otherwise)​​
table_size(store,tableaddr):u32

    Return the length of store.tables[tableaddr].elem.

 table_size(S,a)​=​n​​(if∣S.tables[a].elem∣=n)​​
table_grow(store,tableaddr,n:u32):store ∣ error

    Try growing the table instance store.tables[tableaddr] by n elements:

        If it succeeds, return the updated store.

        Else, return error.

 table_grow(S,a,n)table_grow(S,a,n)​==​S′error​​(ifS′=Swithtables[a]=growtable(S.tables[a],n))(otherwise)​​
Memories
mem_alloc(store,memtype):(store,memaddr)

    Pre-condition: memtype is valid<valid−memtype>.

    Let memaddr be the result of allocating a memory in store with memory type memtype.

    Return the new store paired with memaddr.

mem_alloc(S,mt)​=​(S′,a)​​(ifallocmem(S,mt)=S′,a)​​
mem_type(store,memaddr):memtype

    Assert: the external value mem memaddr is valid with external type mem memtype.

    Return memtype.

    Post-condition: memtype is valid<valid−memtype>.

mem_type(S,a)​=​mt​​(ifS⊢mem a:mem mt)​​
mem_read(store,memaddr,i:u32):byte ∣ error

    Let mi be the memory instance store.mems[memaddr].

    If i is larger than or equal to the length of mi.data, then return error.

    Else, return the byte mi.data[i].

mem_read(S,a,i)mem_read(S,a,i)​==​berror​​(ifS.mems[a].data[i]=b)(otherwise)​​
mem_write(store,memaddr,i:u32,byte):store ∣ error

    Let mi be the memory instance store.mems[memaddr].

    If u32 is larger than or equal to the length of mi.data, then return error.

    Replace mi.data[i] with byte.

    Return the updated store.

mem_write(S,a,i,b)mem_write(S,a,i,b)​==​S′error​​(ifS′=Swithmems[a].data[i]=b)(otherwise)​​
mem_size(store,memaddr):u32

    Return the length of store.mems[memaddr].data divided by the page size.

 mem_size(S,a)​=​n​​(if∣S.mems[a].data∣=n⋅64Ki)​​
mem_grow(store,memaddr,n:u32):store ∣ error

    Try growing the memory instance store.mems[memaddr] by n pages:

        If it succeeds, return the updated store.

        Else, return error.

 mem_grow(S,a,n)mem_grow(S,a,n)​==​S′error​​(ifS′=Swithmems[a]=growmem(S.mems[a],n))(otherwise)​​
Globals
global_alloc(store,globaltype,val):(store,globaladdr)

    Pre-condition: globaltype is valid<valid−globaltype>.

    Let globaladdr be the result of allocating a global in store with global type globaltype and initialization value val.

    Return the new store paired with globaladdr.

global_alloc(S,gt,v)​=​(S′,a)​​(ifallocglobal(S,gt,v)=S′,a)​​
global_type(store,globaladdr):globaltype

    Assert: the external value global globaladdr is valid with external type global globaltype.

    Return globaltype.

    Post-condition: globaltype is valid<valid−globaltype>.

global_type(S,a)​=​gt​​(ifS⊢global a:global gt)​​
global_read(store,globaladdr):val

    Let gi be the global instance store.globals[globaladdr].

    Return the value gi.value.

global_read(S,a)​=​v​​(ifS.globals[a].value=v)​​
global_write(store,globaladdr,val):store ∣ error

    Let gi be the global instance store.globals[globaladdr].

    If gi.mut is not var, then return error.

    Replace gi.value with the value val.

    Return the updated store.

 global_write(S,a,v)global_write(S,a,v)​==​S′error​​(ifS.globals[a].mut=var∧S′=Swithglobals[a].value=v)(otherwise)​​
A.2 Implementation Limitations

Implementations typically impose additional restrictions on a number of aspects of a WebAssembly module or execution. These may stem from:

    physical resource limits,

    constraints imposed by the embedder or its environment,

    limitations of selected implementation strategies.

This section lists allowed limitations. Where restrictions take the form of numeric limits, no minimum requirements are given, nor are the limits assumed to be concrete, fixed numbers. However, it is expected that all implementations have “reasonably” large limits to enable common applications.

Note

A conforming implementation is not allowed to leave out individual features. However, designated subsets of WebAssembly may be specified in the future.
Syntactic Limits
Structure

An implementation may impose restrictions on the following dimensions of a module:

    the number of types in a module

    the number of functions in a module, including imports

    the number of tables in a module, including imports

    the number of memories in a module, including imports

    the number of globals in a module, including imports

    the number of element segments in a module

    the number of data segments in a module

    the number of imports to a module

    the number of exports from a module

    the number of parameters in a function type

    the number of results in a function type

    the number of parameters in a block type

    the number of results in a block type

    the number of locals in a function

    the size of a function body

    the size of a structured control instruction

    the number of structured control instructions in a function

    the nesting depth of structured control instructions

    the number of label indices in a br_table instruction

    the length of an element segment

    the length of a data segment

    the length of a name

    the range of characters in a name

If the limits of an implementation are exceeded for a given module, then the implementation may reject the validation, compilation, or instantiation of that module with an embedder-specific error.

Note

The last item allows embedders that operate in limited environments without support for [UNICODE] to limit the names of imports and exports to common subsets like ASCII.
Binary Format

For a module given in binary format, additional limitations may be imposed on the following dimensions:

    the size of a module

    the size of any section

    the size of an individual function’s code

    the number of sections

Text Format

For a module given in text format, additional limitations may be imposed on the following dimensions:

    the size of the source text

    the size of any syntactic element

    the size of an individual token

    the nesting depth of folded instructions

    the length of symbolic identifiers

    the range of literal characters allowed in the source text

Validation

An implementation may defer validation of individual functions until they are first invoked.

If a function turns out to be invalid, then the invocation, and every consecutive call to the same function, results in a trap.

Note

This is to allow implementations to use interpretation or just-in-time compilation for functions. The function must still be fully validated before execution of its body begins.
Execution

Restrictions on the following dimensions may be imposed during execution of a WebAssembly program:

    the number of allocated module instances

    the number of allocated function instances

    the number of allocated table instances

    the number of allocated memory instances

    the number of allocated global instances

    the size of a table instance

    the size of a memory instance

    the number of frames on the stack

    the number of labels on the stack

    the number of values on the stack

If the runtime limits of an implementation are exceeded during execution of a computation, then it may terminate that computation and report an embedder-specific error to the invoking code.

Some of the above limits may already be verified during instantiation, in which case an implementation may report exceedance in the same manner as for syntactic limits.

Note

Concrete limits are usually not fixed but may be dependent on specifics, interdependent, vary over time, or depend on other implementation- or embedder-specific situations or events.
A.3 Validation Algorithm

The specification of WebAssembly validation is purely declarative. It describes the constraints that must be met by a module or instruction sequence to be valid.

This section sketches the skeleton of a sound and complete algorithm for effectively validating code, i.e., sequences of instructions. (Other aspects of validation are straightforward to implement.)

In fact, the algorithm is expressed over the flat sequence of opcodes as occurring in the binary format, and performs only a single pass over it. Consequently, it can be integrated directly into a decoder.

The algorithm is expressed in typed pseudo code whose semantics is intended to be self-explanatory.
Data Structures

The algorithm uses two separate stacks: the operand stack and the control stack. The former tracks the types of operand values on the stack, the latter surrounding structured control instructions and their associated blocks.

type val_type = I32 | I64 | F32 | F64

type opd_stack = stack(val_type | Unknown)

type ctrl_stack = stack(ctrl_frame)
type ctrl_frame = {
  opcode : opcode
  start_types : list(val_type)
  end_types : list(val_type)
  height : nat
  unreachable : bool
}

For each value, the operand stack records its value type, or Unknown when the type is not known.

For each entered block, the control stack records a control frame with the originating opcode, the types on the top of the operand stack at the start and end of the block (used to check its result as well as branches), the height of the operand stack at the start of the block (used to check that operands do not underflow the current block), and a flag recording whether the remainder of the block is unreachable (used to handle stack-polymorphic typing after branches).

For the purpose of presenting the algorithm, the operand and control stacks are simply maintained as global variables:

var opds : opd_stack
var ctrls : ctrl_stack

However, these variables are not manipulated directly by the main checking function, but through a set of auxiliary functions:

func push_opd(type : val_type | Unknown) =
  opds.push(type)

func pop_opd() : val_type | Unknown =
  if (opds.size() = ctrls[0].height && ctrls[0].unreachable) return Unknown
  error_if(opds.size() = ctrls[0].height)
  return opds.pop()

func pop_opd(expect : val_type | Unknown) : val_type | Unknown =
  let actual = pop_opd()
  if (actual = Unknown) return expect
  if (expect = Unknown) return actual
  error_if(actual =/= expect)
  return actual

func push_opds(types : list(val_type)) = foreach (t in types) push_opd(t)
func pop_opds(types : list(val_type)) = foreach (t in reverse(types)) pop_opd(t)

Pushing an operand simply pushes the respective type to the operand stack.

Popping an operand checks that the operand stack does not underflow the current block and then removes one type. But first, a special case is handled where the block contains no known operands, but has been marked as unreachable. That can occur after an unconditional branch, when the stack is typed polymorphically. In that case, an unknown type is returned.

A second function for popping an operand takes an expected type, which the actual operand type is checked against. The types may differ in case one of them is Unknown. The more specific type is returned.

Finally, there are accumulative functions for pushing or popping multiple operand types.

Note

The notation stack[i] is meant to index the stack from the top, so that ctrls[0] accesses the element pushed last.

The control stack is likewise manipulated through auxiliary functions:

func push_ctrl(opcode : opcode, in : list(val_type), out : list(val_type)) =
  let frame = ctrl_frame(opcode, in, out, opds.size(), false)
  ctrls.push(frame)
  push_opds(in)

func pop_ctrl() : ctrl_frame =
  error_if(ctrls.is_empty())
  let frame = ctrls[0]
  pop_opds(frame.end_types)
  error_if(opds.size() =/= frame.height)
  ctrls.pop()
  return frame

func label_types(frame : ctrl_frame) : list(val_types) =
  return (if frame.opcode == loop then frame.start_types else frame.end_types)

func unreachable() =
  opds.resize(ctrls[0].height)
  ctrls[0].unreachable := true

Pushing a control frame takes the types of the label and result values. It allocates a new frame record recording them along with the current height of the operand stack and marks the block as reachable.

Popping a frame first checks that the control stack is not empty. It then verifies that the operand stack contains the right types of values expected at the end of the exited block and pops them off the operand stack. Afterwards, it checks that the stack has shrunk back to its initial height.

The type of the label associated with a control frame is either that of the stack at the start or the end of the frame, determined by the opcode that it originates from.

Finally, the current frame can be marked as unreachable. In that case, all existing operand types are purged from the operand stack, in order to allow for the stack-polymorphism logic in pop_opd to take effect.

Note

Even with the unreachable flag set, consecutive operands are still pushed to and popped from the operand stack. That is necessary to detect invalid examples like (unreachable (i32.const) i64.add). However, a polymorphic stack cannot underflow, but instead generates Unknown types as needed.
Validation of Opcode Sequences

The following function shows the validation of a number of representative instructions that manipulate the stack. Other instructions are checked in a similar manner.

Note

Various instructions not shown here will additionally require the presence of a validation context for checking uses of indices. That is an easy addition and therefore omitted from this presentation.

func validate(opcode) =
  switch (opcode)
    case (i32.add)
      pop_opd(I32)
      pop_opd(I32)
      push_opd(I32)

   case (drop)
      pop_opd()

   case (select)
      pop_opd(I32)
      let t1 = pop_opd()
      let t2 = pop_opd(t1)
      push_opd(t2)

   case (unreachable)
      unreachable()

   case (block t1*->t2*)
      pop_opds([t1*])
      push_ctrl(block, [t1*], [t2*])

   case (loop t1*->t2*)
      pop_opds([t1*])
      push_ctrl(loop, [t1*], [t2*])

   case (if t1*->t2*)
      pop_opd(I32)
      pop_opds([t1*])
      push_ctrl(if, [t1*], [t2*])

   case (end)
      let frame = pop_ctrl()
      push_opds(frame.end_types)

   case (else)
      let frame = pop_ctrl()
      error_if(frame.opcode =/= if)
      push_ctrl(else, frame.start_types, frame.end_types)

   case (br n)
      error_if(ctrls.size() < n)
      pop_opds(label_types(ctrls[n]))
      unreachable()

   case (br_if n)
      error_if(ctrls.size() < n)
      pop_opd(I32)
      pop_opds(label_types(ctrls[n]))
      push_opds(label_types(ctrls[n]))

   case (br_table n* m)
      error_if(ctrls.size() < m)
      foreach (n in n*)
        error_if(ctrls.size() < n || label_types(ctrls[n]) =/= label_types(ctrls[m]))
      pop_opd(I32)
      pop_opds(label_types(ctrls[m]))
      unreachable()

Note

It is an invariant under the current WebAssembly instruction set that an operand of Unknown type is never duplicated on the stack. This would change if the language were extended with stack instructions like dup. Under such an extension, the above algorithm would need to be refined by replacing the Unknown type with proper type variables to ensure that all uses are consistent.
A.4 Custom Sections

This appendix defines dedicated custom sections for WebAssembly’s binary format. Such sections do not contribute to, or otherwise affect, the WebAssembly semantics, and like any custom section they may be ignored by an implementation. However, they provide useful meta data that implementations can make use of to improve user experience or take compilation hints.

Currently, only one dedicated custom section is defined, the name section.
Name Section

The name section is a custom section whose name string is itself ‘name’. The name section should appear only once in a module, and only after the data section.

The purpose of this section is to attach printable names to definitions in a module, which e.g. can be used by a debugger or when parts of the module are to be rendered in text form.

Note

All names are represented in [UNICODE] encoded in UTF-8. Names need not be unique.
Subsections

The data of a name section consists of a sequence of subsections. Each subsection consists of a

    a one-byte subsection id,

    the u32 size of the contents, in bytes,

    the actual contents, whose structure is depended on the subsection id.

​namesecnamedatanamesubsectionN​(B)​::=::=::=​section0​(namedata)n:namemodulenamesubsec?funcnamesubsec?localnamesubsec?N:byte  size:u32  B​(ifn=‘name’)(ifsize=∣∣B∣∣)​​

The following subsection ids are used:

Id
	

Subsection

0
	

module name

1
	

function names

2
	

local names

Each subsection may occur at most once, and in order of increasing id.
Name Maps

A name map assigns names to indices in a given index space. It consists of a vector of index/name pairs in order of increasing index value. Each index must be unique, but the assigned names need not be.
​namemapnameassoc​::=::=​vec(nameassoc)idx name​​

An indirect name map assigns names to a two-dimensional index space, where secondary indices are grouped by primary indices. It consists of a vector of primary index/name map pairs in order of increasing index value, where each name map in turn maps secondary indices to names. Each primary index must be unique, and likewise each secondary index per individual name map.
​indirectnamemapindirectnameassoc​::=::=​vec(indirectnameassoc)idx namemap​​
Module Names

The module name subsection has the id 0. It simply consists of a single name that is assigned to the module itself.
​modulenamesubsec​::=​namesubsection0​(name)​​
Function Names

The function name subsection has the id 1. It consists of a name map assigning function names to function indices.
​funcnamesubsec​::=​namesubsection1​(namemap)​​
Local Names

The local name subsection has the id 2. It consists of an indirect name map assigning local names to local indices grouped by function indices.
​localnamesubsec​::=​namesubsection2​(indirectnamemap)​​
A.5 Soundness

The type system of WebAssembly is sound, implying both type safety and memory safety with respect to the WebAssembly semantics. For example:

    All types declared and derived during validation are respected at run time; e.g., every local or global variable will only contain type-correct values, every instruction will only be applied to operands of the expected type, and every function invocation always evaluates to a result of the right type (if it does not trap or diverge).

    No memory location will be read or written except those explicitly defined by the program, i.e., as a local, a global, an element in a table, or a location within a linear memory.

    There is no undefined behavior, i.e., the execution rules cover all possible cases that can occur in a valid program, and the rules are mutually consistent.

Soundness also is instrumental in ensuring additional properties, most notably, encapsulation of function and module scopes: no locals can be accessed outside their own function and no module components can be accessed outside their own module unless they are explicitly exported or imported.

The typing rules defining WebAssembly validation only cover the static components of a WebAssembly program. In order to state and prove soundness precisely, the typing rules must be extended to the dynamic components of the abstract runtime, that is, the store, configurations, and administrative instructions. 1
Values and Results

Values and results can be classified by value types and result types as follows.
Values t.const c

    The value is valid with value type t.

⊢t.const c:t​
Results val∗

    For each value vali​ in val∗:

        The value vali​ is valid with some value type ti​.

    Let t∗ be the concatenation of all ti​.

    Then the result is valid with result type [t∗].

⊢val∗:[t∗](⊢val:t)∗​
Results trap

    The result is valid with result type [t∗], for any sequence t∗ of value types.

⊢trap:[t∗]​
Store Validity

The following typing rules specify when a runtime store S is valid. A valid store must consist of function, table, memory, global, and module instances that are themselves valid, relative to S.

To that end, each kind of instance is classified by a respective function, table, memory, or global type. Module instances are classified by module contexts, which are regular contexts repurposed as module types describing the index spaces defined by a module.
Store S

    Each function instance funcinsti​ in S.funcs must be valid with some function type functypei​.

    Each table instance tableinsti​ in S.tables must be valid with some table type tabletypei​.

    Each memory instance meminsti​ in S.mems must be valid with some memory type memtypei​.

    Each global instance globalinsti​ in S.globals must be valid with some global type globaltypei​.

    Then the store is valid.

 ⊢Sok(S⊢funcinst:functype)∗(S⊢tableinst:tabletype)∗(S⊢meminst:memtype)∗(S⊢globalinst:globaltype)∗S={funcs funcinst∗,tables tableinst∗,mems meminst∗,globals globalinst∗}​​​
Function Instances {type functype,module moduleinst,code func}

    The function type functype must be valid.

    The module instance moduleinst must be valid with some context C.

    Under context C, the function func must be valid with function type functype.

    Then the function instance is valid with function type functype.

S⊢{type functype,module moduleinst,code func}:functype⊢functypeokS⊢moduleinst:CC⊢func:functype​
Host Function Instances {type functype,hostcode hf}

    The function type functype must be valid.

    Let [t1∗​]→[t2∗​] be the function type functype.

    For every valid store S1​ extending S and every sequence val∗ of values whose types coincide with t1∗​:

        Executing hf in store S1​ with arguments val∗ has a non-empty set of possible outcomes.

        For every element R of this set:

            Either R must be ⊥ (i.e., divergence).

            Or R consists of a valid store S2​ extending S1​ and a result result whose type coincides with [t2∗​].

    Then the function instance is valid with function type functype.

S⊢{type [t1∗​]→[t2∗​],hostcode hf}:[t1∗​]→[t2∗​]⊢[t1∗​]→[t2∗​]ok​∀S1​,val∗, ⊢S1​ok∧⊢S⪯S1​∧⊢val∗:[t1∗​]⟹hf(S1​;val∗)⊃∅∧∀R∈hf(S1​;val∗), R=⊥∨∃S2​,result, ⊢S2​ok∧⊢S1​⪯S2​∧⊢result:[t2∗​]∧R=(S2​;result)​​​

Note

This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the host function must satisfy appropriate post-conditions about store and results. The post-conditions match the ones in the execution rule for invoking host functions.

Any store under which the function is invoked is assumed to be an extension of the current store. That way, the function itself is able to make sufficient assumptions about future stores.
Table Instances {elem (fa?)n,max m?}

    For each optional function address fai?​ in the table elements (fa?)n:

        Either fai?​ is empty.

        Or the external value func fa must be valid with some external type func ft.

    The limits {min n,max m?} must be valid within range 232.

    Then the table instance is valid with table type {min n,max m?} funcref.

S⊢{elem (fa?)n,max m?}:{min n,max m?} funcref((S⊢func fa:func functype)?)n⊢{min n,max m?}:232​
Memory Instances {data bn,max m?}

    The limits {min n,max m?} must be valid within range 216.

    Then the memory instance is valid with memory type {min n,max m?}.

S⊢{data bn,max m?}:{min n,max m?}⊢{min n,max m?}:216​
Global Instances {value (t.const c),mut mut}

    The global instance is valid with global type mut t.

S⊢{value (t.const c),mut mut}:mut t​
Export Instances {name name,value externval}

    The external value externval must be valid with some external type externtype.

    Then the export instance is valid.

S⊢{name name,value externval}okS⊢externval:externtype​
Module Instances moduleinst

    Each function type functypei​ in moduleinst.types must be valid.

    For each function address funcaddri​ in moduleinst.funcaddrs, the external value func funcaddri​ must be valid with some external type func functypei′​.

    For each table address tableaddri​ in moduleinst.tableaddrs, the external value table tableaddri​ must be valid with some external type table tabletypei​.

    For each memory address memaddri​ in moduleinst.memaddrs, the external value mem memaddri​ must be valid with some external type mem memtypei​.

    For each global address globaladdri​ in moduleinst.globaladdrs, the external value global globaladdri​ must be valid with some external type global globaltypei​.

    Each export instance exportinsti​ in moduleinst.exports must be valid.

    For each export instance exportinsti​ in moduleinst.exports, the name exportinsti​.name must be different from any other name occurring in moduleinst.exports.

    Let functype′∗ be the concatenation of all functypei′​ in order.

    Let tabletype∗ be the concatenation of all tabletypei​ in order.

    Let memtype∗ be the concatenation of all memtypei​ in order.

    Let globaltype∗ be the concatenation of all globaltypei​ in order.

    Then the module instance is valid with context {types functype∗,funcs functype′∗,tables tabletype∗,mems memtype∗,globals globaltype∗}.

 S⊢{typesfuncaddrstableaddrsmemaddrsglobaladdrsexports​functype∗,funcaddr∗,tableaddr∗,memaddr∗,globaladdr∗exportinst∗ }:{typesfuncstablesmemsglobals​functype∗,functype′∗,tabletype∗,memtype∗,globaltype∗ }​​(⊢functypeok)∗(S⊢func funcaddr:func functype′)∗(S⊢table tableaddr:table tabletype)∗(S⊢mem memaddr:mem memtype)∗(S⊢global globaladdr:global globaltype)∗(S⊢exportinstok)∗(exportinst.name)∗ disjoint​​​
Configuration Validity

To relate the WebAssembly type system to its execution semantics, the typing rules for instructions must be extended to configurations S;T, which relates the store to execution threads.

Configurations and threads are classified by their result type. In addition to the store S, threads are typed under a return type resulttype?, which controls whether and with which type a return instruction is allowed. This type is absent (ϵ) except for instruction sequences inside an administrative frame instruction.

Finally, frames are classified with frame contexts, which extend the module contexts of a frame’s associated module instance with the locals that the frame contains.
Configurations S;T

    The store S must be valid.

    Under no allowed return type, the thread T must be valid with some result type [t∗].

    Then the configuration is valid with the result type [t∗].

⊢S;T:[t∗]⊢SokS;ϵ⊢T:[t∗]​
Threads F;instr∗

    Let resulttype? be the current allowed return type.

    The frame F must be valid with a context C.

    Let C′ be the same context as C, but with return set to resulttype?.

    Under context C′, the instruction sequence instr∗ must be valid with some type []→[t∗].

    Then the thread is valid with the result type [t∗].

S;resulttype?⊢F;instr∗:[t∗]S⊢F:CS;C,return resulttype?⊢instr∗:[]→[t∗]​
Frames {locals val∗,module moduleinst}

    The module instance moduleinst must be valid with some module context C.

    Each value vali​ in val∗ must be valid with some value type ti​.

    Let t∗ the concatenation of all ti​ in order.

    Let C′ be the same context as C, but with the value types t∗ prepended to the locals vector.

    Then the frame is valid with frame context C′.

S⊢{locals val∗,module moduleinst}:(C,locals t∗)S⊢moduleinst:C(⊢val:t)∗​
Administrative Instructions

Typing rules for administrative instructions are specified as follows. In addition to the context C, typing of these instructions is defined under a given store S. To that end, all previous typing judgements C⊢prop are generalized to include the store, as in S;C⊢prop, by implicitly adding S to all rules – S is never modified by the pre-existing rules, but it is accessed in the extra rules for administrative instructions given below.
trap

    The instruction is valid with type [t1∗​]→[t2∗​], for any sequences of value types t1∗​ and t2∗​.

S;C⊢trap:[t1∗​]→[t2∗​]​
invoke funcaddr

    The external function value func funcaddr must be valid with external function type func([t1∗​]→[t2∗​]).

    Then the instruction is valid with type [t1∗​]→[t2∗​].

S;C⊢invoke funcaddr:[t1∗​]→[t2∗​]S⊢func funcaddr:func [t1∗​]→[t2∗​]​
init_elem tableaddr o xn

    The external table value table tableaddr must be valid with some external table type table limits funcref.

    The index o+n must be smaller than or equal to limits.min.

    The module instance moduleinst must be valid with some context C.

    Each function index xi​ in xn must be defined in the context C.

    Then the instruction is valid.

S;C⊢init_elem tableaddr o xnokS⊢table tableaddr:table limits funcrefo+n≤limits.min(C.funcs[x]=functype)n​
init_data memaddr o bn

    The external memory value mem memaddr must be valid with some external memory type mem limits.

    The index o+n must be smaller than or equal to limits.min divided by the page size 64Ki.

    Then the instruction is valid.

S;C⊢init_data memaddr o bnokS⊢mem memaddr:mem limitso+n≤limits.min⋅64Ki​
labeln​{instr0∗​} instr∗ end

    The instruction sequence instr0∗​ must be valid with some type [t1n​]→[t2∗​].

    Let C′ be the same context as C, but with the result type [t1n​] prepended to the labels vector.

    Under context C′, the instruction sequence instr∗ must be valid with type []→[t2∗​].

    Then the compound instruction is valid with type []→[t2∗​].

] \qquad S; C,\href{#context}{\mathsf{labels}}\,[t_1^n] \href{#valid-instr-seq}{\vdash} \href{#syntax-instr}{\mathit{instr}}^\ast : [] \href{#syntax-functype}{\rightarrow} [t_2^] }{ S; C \href{#valid-instr-admin}{\vdash} \href{#syntax-label}{\mathsf{label}}_n\{\href{#syntax-instr}{\mathit{instr}}_0^\ast\}~\href{#syntax-instr}{\mathit{instr}}^\ast~\href{#syntax-instr-control}{\mathsf{end}} : [] \href{#syntax-functype}{\rightarrow} [t_2^*] }\]
framen​{F} instr∗ end

    Under the return type [tn], the thread F;instr∗ must be valid with result type [tn].

    Then the compound instruction is valid with type []→[tn].

S;C⊢framen​{F} instr∗ end:[]→[tn]S;[tn]⊢F;instr∗:[tn]​
Store Extension

Programs can mutate the store and its contained instances. Any such modification must respect certain invariants, such as not removing allocated instances or changing immutable definitions. While these invariants are inherent to the execution semantics of WebAssembly instructions and modules, host functions do not automatically adhere to them. Consequently, the required invariants must be stated as explicit constraints on the invocation of host functions. Soundness only holds when the embedder ensures these constraints.

The necessary constraints are codified by the notion of store extension: a store state S′ extends state S, written S⪯S′, when the following rules hold.

Note

Extension does not imply that the new store is valid, which is defined separately above.
Store S

    The length of S.funcs must not shrink.

    The length of S.tables must not shrink.

    The length of S.mems must not shrink.

    The length of S.globals must not shrink.

    For each function instance funcinsti​ in the original S.funcs, the new function instance must be an extension of the old.

    For each table instance tableinsti​ in the original S.tables, the new table instance must be an extension of the old.

    For each memory instance meminsti​ in the original S.mems, the new memory instance must be an extension of the old.

    For each global instance globalinsti​ in the original S.globals, the new global instance must be an extension of the old.

⊢S1​⪯S2​S1​.funcs=funcinst1∗​S1​.tables=tableinst1∗​S1​.mems=meminst1∗​S1​.globals=globalinst1∗​​S2​.funcs=funcinst1′​∗ funcinst2∗​S2​.tables=tableinst1′​∗ tableinst2∗​S2​.mems=meminst1′​∗ meminst2∗​S2​.globals=globalinst1′​∗ globalinst2∗​​(funcinst1​⪯funcinst1′​)∗(tableinst1​⪯tableinst1′​)∗(meminst1​⪯meminst1′​)∗(globalinst1​⪯globalinst1′​)∗​​​
Function Instance funcinst

    A function instance must remain unchanged.

⊢funcinst⪯funcinst​
Table Instance tableinst

    The length of tableinst.elem must not shrink.

    The value of tableinst.max must remain unchanged.

⊢{elem (fa1?​)n1​,max m}⪯{elem (fa2?​)n2​,max m}n1​≤n2​​
Memory Instance meminst

    The length of meminst.data must not shrink.

    The value of meminst.max must remain unchanged.

⊢{data b1n1​​,max m}⪯{data b2n2​​,max m}n1​≤n2​​
Global Instance globalinst

    The mutability globalinst.mut must remain unchanged.

    The value type of the value globalinst.value must remain unchanged.

    If globalinst.mut is const, then the value globalinst.value must remain unchanged.

⊢{value (t.const c1​),mut mut}⪯{value (t.const c2​),mut mut}mut=var∨c1​=c2​​
Theorems

Given the definition of valid configurations, the standard soundness theorems hold. 2

Theorem (Preservation). If a configuration S;T is valid with result type [t∗] (i.e., ⊢S;T:[t∗]), and steps to S′;T′ (i.e., S;T↪S′;T′), then S′;T′ is a valid configuration with the same result type (i.e., ⊢S′;T′:[t∗]). Furthermore, S′ is an extension of S (i.e., ⊢S⪯S′).

A terminal thread is one whose sequence of instructions is a result. A terminal configuration is a configuration whose thread is terminal.

Theorem (Progress). If a configuration S;T is valid (i.e., ⊢S;T:[t∗] for some result type [t∗]), then either it is terminal, or it can step to some configuration S′;T′ (i.e., S;T↪S′;T′).

From Preservation and Progress the soundness of the WebAssembly type system follows directly.

Corollary (Soundness). If a configuration S;T is valid (i.e., ⊢S;T:[t∗] for some result type [t∗]), then it either diverges or takes a finite number of steps to reach a terminal configuration S′;T′ (i.e., S;T↪∗S′;T′) that is valid with the same result type (i.e., ⊢S′;T′:[t∗]) and where S′ is an extension of S (i.e., ⊢S⪯S′).

In other words, every thread in a valid configuration either runs forever, traps, or terminates with a result that has the expected type. Consequently, given a valid store, no computation defined by instantiation or invocation of a valid module can “crash” or otherwise (mis)behave in ways not covered by the execution semantics given in this specification.

1

    The formalization and theorems are derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
2

    A machine-verified version of the formalization and soundness proof is described in the following article: Conrad Watt. Mechanising and Verifying the WebAssembly Specification. Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2018). ACM 2018.

A.6 Index of Types

Category
	

Constructor
	

Binary Opcode

Type index
	

x
	

(positive number as s32 or u32)

Value type
	

i32
	

0x7F (-1 as s7)

Value type
	

i64
	

0x7E (-2 as s7)

Value type
	

f32
	

0x7D (-3 as s7)

Value type
	

f64
	

0x7C (-4 as s7)

(reserved)
		

0x7B .. 0x71

Element type
	

funcref
	

0x70 (-16 as s7)

(reserved)
		

0x6F .. 0x61

Function type
	

[valtype∗]→[valtype∗]
	

0x60 (-32 as s7)

(reserved)
		

0x5F .. 0x41

Result type
	

[ϵ]
	

0x40 (-64 as s7)

Table type
	

limits elemtype
	

(none)

Memory type
	

limits
	

(none)

Global type
	

mut valtype
	

(none)
A.7 Index of Instructions

Instruction
	

Binary Opcode
	

Type
	

Validation
	

Execution

unreachable
	

0x00
	

[t1∗​]→[t2∗​]
	

validation
	

execution

nop
	

0x01
	

[]→[]
	

validation
	

execution

block bt
	

0x02
	

[t1∗​]→[t2∗​]
	

validation
	

execution

loop bt
	

0x03
	

[t1∗​]→[t2∗​]
	

validation
	

execution

if bt
	

0x04
	

[t1∗​]→[t2∗​]
	

validation
	

execution

else
	

0x05
			

(reserved)
	

0x06
			

(reserved)
	

0x07
			

(reserved)
	

0x08
			

(reserved)
	

0x09
			

(reserved)
	

0x0A
			

end
	

0x0B
			

br l
	

0x0C
	

[t1∗​ t∗]→[t2∗​]
	

validation
	

execution

br_if l
	

0x0D
	

[t∗ i32]→[t∗]
	

validation
	

execution

br_table l∗ l
	

0x0E
	

[t1∗​ t∗ i32]→[t2∗​]
	

validation
	

execution

return
	

0x0F
	

[t1∗​ t∗]→[t2∗​]
	

validation
	

execution

call x
	

0x10
	

[t1∗​]→[t2∗​]
	

validation
	

execution

call_indirect x
	

0x11
	

[t1∗​ i32]→[t2∗​]
	

validation
	

execution

(reserved)
	

0x12
			

(reserved)
	

0x13
			

(reserved)
	

0x14
			

(reserved)
	

0x15
			

(reserved)
	

0x16
			

(reserved)
	

0x17
			

(reserved)
	

0x18
			

(reserved)
	

0x19
			

drop
	

0x1A
	

[t]→[]
	

validation
	

execution

select
	

0x1B
	

[t t i32]→[t]
	

validation
	

execution

(reserved)
	

0x1C
			

(reserved)
	

0x1D
			

(reserved)
	

0x1E
			

(reserved)
	

0x1F
			

local.get x
	

0x20
	

[]→[t]
	

validation
	

execution

local.set x
	

0x21
	

[t]→[]
	

validation
	

execution

local.tee x
	

0x22
	

[t]→[t]
	

validation
	

execution

global.get x
	

0x23
	

[]→[t]
	

validation
	

execution

global.set x
	

0x24
	

[t]→[]
	

validation
	

execution

(reserved)
	

0x25
			

(reserved)
	

0x26
			

(reserved)
	

0x27
			

i32.load memarg
	

0x28
	

[i32]→[i32]
	

validation
	

execution

i64.load memarg
	

0x29
	

[i32]→[i64]
	

validation
	

execution

f32.load memarg
	

0x2A
	

[i32]→[f32]
	

validation
	

execution

f64.load memarg
	

0x2B
	

[i32]→[f64]
	

validation
	

execution

i32.load8_s memarg
	

0x2C
	

[i32]→[i32]
	

validation
	

execution

i32.load8_u memarg
	

0x2D
	

[i32]→[i32]
	

validation
	

execution

i32.load16_s memarg
	

0x2E
	

[i32]→[i32]
	

validation
	

execution

i32.load16_u memarg
	

0x2F
	

[i32]→[i32]
	

validation
	

execution

i64.load8_s memarg
	

0x30
	

[i32]→[i64]
	

validation
	

execution

i64.load8_u memarg
	

0x31
	

[i32]→[i64]
	

validation
	

execution

i64.load16_s memarg
	

0x32
	

[i32]→[i64]
	

validation
	

execution

i64.load16_u memarg
	

0x33
	

[i32]→[i64]
	

validation
	

execution

i64.load32_s memarg
	

0x34
	

[i32]→[i64]
	

validation
	

execution

i64.load32_u memarg
	

0x35
	

[i32]→[i64]
	

validation
	

execution

i32.store memarg
	

0x36
	

[i32 i32]→[]
	

validation
	

execution

i64.store memarg
	

0x37
	

[i32 i64]→[]
	

validation
	

execution

f32.store memarg
	

0x38
	

[i32 f32]→[]
	

validation
	

execution

f64.store memarg
	

0x39
	

[i32 f64]→[]
	

validation
	

execution

i32.store8 memarg
	

0x3A
	

[i32 i32]→[]
	

validation
	

execution

i32.store16 memarg
	

0x3B
	

[i32 i32]→[]
	

validation
	

execution

i64.store8 memarg
	

0x3C
	

[i32 i64]→[]
	

validation
	

execution

i64.store16 memarg
	

0x3D
	

[i32 i64]→[]
	

validation
	

execution

i64.store32 memarg
	

0x3E
	

[i32 i64]→[]
	

validation
	

execution

memory.size
	

0x3F
	

[]→[i32]
	

validation
	

execution

memory.grow
	

0x40
	

[i32]→[i32]
	

validation
	

execution

i32.const i32
	

0x41
	

[]→[i32]
	

validation
	

execution

i64.const i64
	

0x42
	

[]→[i64]
	

validation
	

execution

f32.const f32
	

0x43
	

[]→[f32]
	

validation
	

execution

f64.const f64
	

0x44
	

[]→[f64]
	

validation
	

execution

i32.eqz
	

0x45
	

[i32]→[i32]
	

validation
	

execution, operator

i32.eq
	

0x46
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.ne
	

0x47
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.lt_s
	

0x48
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.lt_u
	

0x49
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.gt_s
	

0x4A
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.gt_u
	

0x4B
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.le_s
	

0x4C
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.le_u
	

0x4D
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.ge_s
	

0x4E
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.ge_u
	

0x4F
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i64.eqz
	

0x50
	

[i64]→[i32]
	

validation
	

execution, operator

i64.eq
	

0x51
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.ne
	

0x52
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.lt_s
	

0x53
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.lt_u
	

0x54
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.gt_s
	

0x55
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.gt_u
	

0x56
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.le_s
	

0x57
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.le_u
	

0x58
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.ge_s
	

0x59
	

[i64 i64]→[i32]
	

validation
	

execution, operator

i64.ge_u
	

0x5A
	

[i64 i64]→[i32]
	

validation
	

execution, operator

f32.eq
	

0x5B
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f32.ne
	

0x5C
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f32.lt
	

0x5D
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f32.gt
	

0x5E
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f32.le
	

0x5F
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f32.ge
	

0x60
	

[f32 f32]→[i32]
	

validation
	

execution, operator

f64.eq
	

0x61
	

[f64 f64]→[i32]
	

validation
	

execution, operator

f64.ne
	

0x62
	

[f64 f64]→[i32]
	

validation
	

execution, operator

f64.lt
	

0x63
	

[f64 f64]→[i32]
	

validation
	

execution, operator

f64.gt
	

0x64
	

[f64 f64]→[i32]
	

validation
	

execution, operator

f64.le
	

0x65
	

[f64 f64]→[i32]
	

validation
	

execution, operator

f64.ge
	

0x66
	

[f64 f64]→[i32]
	

validation
	

execution, operator

i32.clz
	

0x67
	

[i32]→[i32]
	

validation
	

execution, operator

i32.ctz
	

0x68
	

[i32]→[i32]
	

validation
	

execution, operator

i32.popcnt
	

0x69
	

[i32]→[i32]
	

validation
	

execution, operator

i32.add
	

0x6A
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.sub
	

0x6B
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.mul
	

0x6C
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.div_s
	

0x6D
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.div_u
	

0x6E
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.rem_s
	

0x6F
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.rem_u
	

0x70
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.and
	

0x71
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.or
	

0x72
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.xor
	

0x73
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.shl
	

0x74
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.shr_s
	

0x75
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.shr_u
	

0x76
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.rotl
	

0x77
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i32.rotr
	

0x78
	

[i32 i32]→[i32]
	

validation
	

execution, operator

i64.clz
	

0x79
	

[i64]→[i64]
	

validation
	

execution, operator

i64.ctz
	

0x7A
	

[i64]→[i64]
	

validation
	

execution, operator

i64.popcnt
	

0x7B
	

[i64]→[i64]
	

validation
	

execution, operator

i64.add
	

0x7C
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.sub
	

0x7D
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.mul
	

0x7E
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.div_s
	

0x7F
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.div_u
	

0x80
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.rem_s
	

0x81
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.rem_u
	

0x82
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.and
	

0x83
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.or
	

0x84
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.xor
	

0x85
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.shl
	

0x86
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.shr_s
	

0x87
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.shr_u
	

0x88
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.rotl
	

0x89
	

[i64 i64]→[i64]
	

validation
	

execution, operator

i64.rotr
	

0x8A
	

[i64 i64]→[i64]
	

validation
	

execution, operator

f32.abs
	

0x8B
	

[f32]→[f32]
	

validation
	

execution, operator

f32.neg
	

0x8C
	

[f32]→[f32]
	

validation
	

execution, operator

f32.ceil
	

0x8D
	

[f32]→[f32]
	

validation
	

execution, operator

f32.floor
	

0x8E
	

[f32]→[f32]
	

validation
	

execution, operator

f32.trunc
	

0x8F
	

[f32]→[f32]
	

validation
	

execution, operator

f32.nearest
	

0x90
	

[f32]→[f32]
	

validation
	

execution, operator

f32.sqrt
	

0x91
	

[f32]→[f32]
	

validation
	

execution, operator

f32.add
	

0x92
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.sub
	

0x93
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.mul
	

0x94
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.div
	

0x95
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.min
	

0x96
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.max
	

0x97
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f32.copysign
	

0x98
	

[f32 f32]→[f32]
	

validation
	

execution, operator

f64.abs
	

0x99
	

[f64]→[f64]
	

validation
	

execution, operator

f64.neg
	

0x9A
	

[f64]→[f64]
	

validation
	

execution, operator

f64.ceil
	

0x9B
	

[f64]→[f64]
	

validation
	

execution, operator

f64.floor
	

0x9C
	

[f64]→[f64]
	

validation
	

execution, operator

f64.trunc
	

0x9D
	

[f64]→[f64]
	

validation
	

execution, operator

f64.nearest
	

0x9E
	

[f64]→[f64]
	

validation
	

execution, operator

f64.sqrt
	

0x9F
	

[f64]→[f64]
	

validation
	

execution, operator

f64.add
	

0xA0
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.sub
	

0xA1
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.mul
	

0xA2
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.div
	

0xA3
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.min
	

0xA4
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.max
	

0xA5
	

[f64 f64]→[f64]
	

validation
	

execution, operator

f64.copysign
	

0xA6
	

[f64 f64]→[f64]
	

validation
	

execution, operator

i32.wrap_i64
	

0xA7
	

[i64]→[i32]
	

validation
	

execution, operator

i32.trunc_f32_s
	

0xA8
	

[f32]→[i32]
	

validation
	

execution, operator

i32.trunc_f32_u
	

0xA9
	

[f32]→[i32]
	

validation
	

execution, operator

i32.trunc_f64_s
	

0xAA
	

[f64]→[i32]
	

validation
	

execution, operator

i32.trunc_f64_u
	

0xAB
	

[f64]→[i32]
	

validation
	

execution, operator

i64.extend_i32_s
	

0xAC
	

[i32]→[i64]
	

validation
	

execution, operator

i64.extend_i32_u
	

0xAD
	

[i32]→[i64]
	

validation
	

execution, operator

i64.trunc_f32_s
	

0xAE
	

[f32]→[i64]
	

validation
	

execution, operator

i64.trunc_f32_u
	

0xAF
	

[f32]→[i64]
	

validation
	

execution, operator

i64.trunc_f64_s
	

0xB0
	

[f64]→[i64]
	

validation
	

execution, operator

i64.trunc_f64_u
	

0xB1
	

[f64]→[i64]
	

validation
	

execution, operator

f32.convert_i32_s
	

0xB2
	

[i32]→[f32]
	

validation
	

execution, operator

f32.convert_i32_u
	

0xB3
	

[i32]→[f32]
	

validation
	

execution, operator

f32.convert_i64_s
	

0xB4
	

[i64]→[f32]
	

validation
	

execution, operator

f32.convert_i64_u
	

0xB5
	

[i64]→[f32]
	

validation
	

execution, operator

f32.demote_f64
	

0xB6
	

[f64]→[f32]
	

validation
	

execution, operator

f64.convert_i32_s
	

0xB7
	

[i32]→[f64]
	

validation
	

execution, operator

f64.convert_i32_u
	

0xB8
	

[i32]→[f64]
	

validation
	

execution, operator

f64.convert_i64_s
	

0xB9
	

[i64]→[f64]
	

validation
	

execution, operator

f64.convert_i64_u
	

0xBA
	

[i64]→[f64]
	

validation
	

execution, operator

f64.promote_f32
	

0xBB
	

[f32]→[f64]
	

validation
	

execution, operator

i32.reinterpret_f32
	

0xBC
	

[f32]→[i32]
	

validation
	

execution, operator

i64.reinterpret_f64
	

0xBD
	

[f64]→[i64]
	

validation
	

execution, operator

f32.reinterpret_i32
	

0xBE
	

[i32]→[f32]
	

validation
	

execution, operator

f64.reinterpret_i64
	

0xBF
	

[i64]→[f64]
	

validation
	

execution, operator

i32.extend8_s
	

0xC0
	

[i32]→[i32]
	

validation
	

execution, operator

i32.extend16_s
	

0xC1
	

[i32]→[i32]
	

validation
	

execution, operator

i64.extend8_s
	

0xC2
	

[i64]→[i64]
	

validation
	

execution, operator

i64.extend16_s
	

0xC3
	

[i64]→[i64]
	

validation
	

execution, operator

i64.extend32_s
	

0xC4
	

[i64]→[i64]
	

validation
	

execution, operator

i32.trunc_sat_f32_s
	

0xFC 0x00
	

[f32]→[i32]
	

validation
	

execution, operator

i32.trunc_sat_f32_u
	

0xFC 0x01
	

[f32]→[i32]
	

validation
	

execution, operator

i32.trunc_sat_f64_s
	

0xFC 0x02
	

[f64]→[i32]
	

validation
	

execution, operator

i32.trunc_sat_f64_u
	

0xFC 0x03
	

[f64]→[i32]
	

validation
	

execution, operator

i64.trunc_sat_f32_s
	

0xFC 0x04
	

[f32]→[i64]
	

validation
	

execution, operator

i64.trunc_sat_f32_u
	

0xFC 0x05
	

[f32]→[i64]
	

validation
	

execution, operator

i64.trunc_sat_f64_s
	

0xFC 0x06
	

[f64]→[i64]
	

validation
	

execution, operator

i64.trunc_sat_f64_u
	

0xFC 0x07
	

[f64]→[i64]
	

validation
	

execution, operator
A.8 Index of Semantic Rules
Typing of Static Constructs

Construct
	

Judgement

Limits
	

⊢limits:k

Function type
	

⊢functypeok

Block type
	

⊢blocktypeok

Table type
	

⊢tabletypeok

Memory type
	

⊢memtypeok

Global type
	

⊢globaltypeok

External type
	

⊢externtypeok

Instruction
	

S;C⊢instr:functype

Instruction sequence
	

S;C⊢instr∗:functype

Expression
	

C⊢expr:resulttype

Function
	

C⊢func:functype

Table
	

C⊢table:tabletype

Memory
	

C⊢mem:memtype

Global
	

C⊢global:globaltype

Element segment
	

C⊢elemok

Data segment
	

C⊢dataok

Start function
	

C⊢startok

Export
	

C⊢export:externtype

Export description
	

C⊢exportdesc:externtype

Import
	

C⊢import:externtype

Import description
	

C⊢importdesc:externtype

Module
	

⊢module:externtype∗→externtype∗
Typing of Runtime Constructs

Construct
	

Judgement

Value
	

⊢val:valtype

Result
	

⊢result:resulttype

External value
	

S⊢externval:externtype

Function instance
	

S⊢funcinst:functype

Table instance
	

S⊢tableinst:tabletype

Memory instance
	

S⊢meminst:memtype

Global instance
	

S⊢globalinst:globaltype

Export instance
	

S⊢exportinstok

Module instance
	

S⊢moduleinst:C

Store
	

⊢storeok

Configuration
	

⊢configok

Thread
	

S;resulttype?⊢thread:resulttype

Frame
	

S⊢frame:C
Constantness

Construct
	

Judgement

Constant expression
	

C⊢exprconst

Constant instruction
	

C⊢instrconst
Import Matching

Construct
	

Judgement

Limits
	

⊢limits1​≤limits2​

External type
	

⊢externtype1​≤externtype2​
Store Extension

Construct
	

Judgement

Function instance
	

⊢funcinst1​⪯funcinst2​

Table instance
	

⊢tableinst1​⪯tableinst2​

Memory instance
	

⊢meminst1​⪯meminst2​

Global instance
	

⊢globalinst1​⪯globalinst2​

Store
	

⊢store1​⪯store2​
Execution

Construct
	

Judgement

Instruction
	

S;F;instr∗↪S′;F′;instr′∗

Expression
	

S;F;expr↪S′;F′;expr′

    Index of Types

    Index of Instructions

    Index of Semantic Rules

    Index

Conformance
Document conventions

Conformance requirements are expressed with a combination of descriptive assertions and RFC 2119 terminology. The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in the normative parts of this document are to be interpreted as described in RFC 2119. However, for readability, these words do not appear in all uppercase letters in this specification.

All of the text of this specification is normative except sections explicitly marked as non-normative, examples, and notes. [RFC2119]

Examples in this specification are introduced with the words “for example” or are set apart from the normative text with class="example", like this:

This is an example of an informative example.

Informative notes begin with the word “Note” and are set apart from the normative text with class="note", like this:

Note, this is an informative note.
References
Normative References

[IEEE-754-2019]
    IEEE Standard for Floating-Point Arithmetic. 29 August 2008. URL: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 

